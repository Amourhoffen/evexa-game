<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evexa Buddy</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* CSS Variables for theming */
        :root {
            --primary-color: #6366f1; /* Indigo 500 */
            --secondary-color: #a78bfa; /* Violet 400 */
            --bg-dark: #1a202c; /* Dark charcoal - for body background */
            --bg-card: rgba(45, 55, 72, 0.3); /* Darker gray for cards - semi-transparent for glassmorphism */
            --text-light: #e2e8f0; /* Light gray */
            --text-muted: #a0aec0; /* Muted gray */
            --border-color: rgba(74, 85, 104, 0.4); /* Semi-transparent border */
            --box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(99, 102, 241, 0.15);
            --success-color: #10b981; /* Emerald */
            --warning-color: #f59e0b; /* Amber */
            --danger-color: #ef4444; /* Red */
            --sky-blue: #70c5ce; /* Default sky blue */
            --ground-brown: #d2b48c; /* Default ground brown */

            /* Sidebar specific variables (Dark Mode) - adjusted for glass effect */
            --sidebar-bg: rgba(30, 30, 30, 0.3); /* Dark background - semi-transparent */
            --sidebar-header-bg: rgba(42, 42, 42, 0.4);
            --sidebar-item-bg-hover: rgba(58, 58, 58, 0.5);
            --sidebar-item-text: #e0e0e0;
            --sidebar-item-icon: #a0a0a0;
            --sidebar-active-item-bg: rgba(51, 51, 51, 0.6);
            --sidebar-active-item-text: white;
            --sidebar-active-item-icon: white;
            --sidebar-border: rgba(51, 51, 51, 0.4);
            --sidebar-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);

            /* Bottom Navbar specific variables */
            --bottom-nav-bg: rgba(30, 30, 30, 0.4);
            --bottom-nav-item-color: #e0e0e0;
            --bottom-nav-active-bg: #007aff; /* iOS blue */
            --bottom-nav-active-color: white;
            --bottom-nav-border: rgba(51, 51, 51, 0.4);
            --bottom-nav-shadow: 0 -5px 15px rgba(0, 0, 0, 0.3);

            /* Game specific variables for canvas dimensions */
            --game-canvas-width: 550;
            --game-canvas-height: 450;

            /* Notepad specific colors */
            --notepad-bg: rgba(255, 255, 255, 0.1);
            --notepad-border: rgba(255, 255, 255, 0.2);
            --input-bg: rgba(255, 255, 255, 0.05);
            --input-border: rgba(255, 255, 255, 0.1);
            --tag-bg: rgba(99, 102, 241, 0.2);
            --tag-text: #a78bfa;
            --checklist-bg: rgba(255, 255, 255, 0.03);
            --checklist-border: rgba(255, 255, 255, 0.1);
            --checklist-checked-bg: rgba(16, 185, 129, 0.2);
            --checklist-checked-text: #10b981;
            --progress-bar-bg: #4a5568;
            --progress-bar-fill: var(--primary-color);

            /* Subject colors */
            --subject-math: #4299E1; /* Blue */
            --subject-physics: #38A169; /* Green */
            --subject-coding: #F6AD55; /* Orange */
            --subject-chemistry: #9F7AEA; /* Purple */
            --subject-history: #ECC94B; /* Yellow */
            --subject-literature: #ED8936; /* Dark Orange */
            --subject-biology: #48BB78; /* Light Green */
            --subject-art: #ED64A6; /* Pink */
            --subject-other: #A0AEC0; /* Gray */
        }

        /* Light Mode Variables */
        body.light-mode {
            --primary-color: #4f46e5; /* Indigo 600 */
            --secondary-color: #8b5cf6; /* Violet 500 */
            --bg-dark: #f0f4f8; /* Light blue-gray - for body background */
            --bg-card: rgba(255, 255, 255, 0.6); /* White - semi-transparent for glassmorphism */
            --text-light: #2d3748; /* Dark gray */
            --text-muted: #718096; /* Medium gray */
            --border-color: rgba(203, 213, 224, 0.6); /* Light border - semi-transparent */
            --box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15), 0 0 15px rgba(79, 70, 229, 0.08);
            --success-color: #059669; /* Darker Emerald */
            --warning-color: #d97706; /* Darker Amber */
            --danger-color: #dc2626; /* Darker Red */
            --sky-blue: #87ceeb; /* Lighter sky blue */
            --ground-brown: #deb887; /* Slightly darker brown */

            /* Sidebar specific variables (Light Mode) - adjusted for glass effect */
            --sidebar-bg: rgba(255, 255, 255, 0.6); /* Light background - semi-transparent */
            --sidebar-header-bg: rgba(245, 245, 245, 0.7);
            --sidebar-item-bg-hover: rgba(224, 224, 224, 0.8);
            --sidebar-item-text: #333;
            --sidebar-item-icon: #666;
            --sidebar-active-item-bg: rgba(224, 224, 224, 0.9);
            --sidebar-active-item-text: #333;
            --sidebar-active-item-icon: #333;
            --sidebar-border: rgba(204, 204, 204, 0.6);
            --sidebar-shadow: 5px 0 15px rgba(0, 0, 0, 0.1);

            /* Bottom Navbar specific variables */
            --bottom-nav-bg: rgba(255, 255, 255, 0.7);
            --bottom-nav-item-color: #333;
            --bottom-nav-active-bg: #007aff; /* iOS blue */
            --bottom-nav-active-color: white;
            --bottom-nav-border: rgba(204, 204, 204, 0.6);
            --bottom-nav-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);

            /* Notepad specific colors - Light Mode */
            --notepad-bg: rgba(255, 255, 255, 0.8);
            --notepad-border: rgba(0, 0, 0, 0.1);
            --input-bg: rgba(240, 240, 240, 0.8);
            --input-border: rgba(0, 0, 0, 0.15);
            --tag-bg: rgba(79, 70, 229, 0.1);
            --tag-text: #4f46e5;
            --checklist-bg: rgba(0, 0, 0, 0.02);
            --checklist-border: rgba(0, 0, 0, 0.1);
            --checklist-checked-bg: rgba(5, 150, 105, 0.1);
            --checklist-checked-text: #059669;
            --progress-bar-bg: #e2e8f0;
            --progress-bar-fill: var(--primary-color);
        }
      html {
            scroll-behavior: smooth;
            height: 100%; /* Ensure html takes full height */
                    }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0d1117 100%);
            color: var(--text-light);
            transition: background 0.5s ease, color 0.5s ease;
            overflow-y: auto; /* Allow body to scroll */
            padding: 0;
            box-sizing: border-box;
            height: 100%; /* Ensure body takes full height */
        }

        /* Glassmorphism effect base */
        .glass-effect {
            backdrop-filter: blur(12px); /* Increased blur */
            -webkit-backdrop-filter: blur(12px); /* For Safari support */
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        /* Custom Scrollbar Styling (for WebKit browsers like Chrome, Safari) */
        ::-webkit-scrollbar {
            width: 8px; /* Thin scrollbar */
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1); /* Subtle track */
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.5); /* Semi-transparent grey thumb */
            border-radius: 10px;
            border: 2px solid transparent; /* Creates a gap around the thumb */
            background-clip: padding-box; /* Ensures border doesn't affect thumb size */
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(128, 128, 128, 0.7); /* Slightly darker on hover */
        }

        /* Sidebar Styling */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 60px; /* Default collapsed width */
            background-color: var(--sidebar-bg); /* Use semi-transparent bg for glass */
            transition: width 0.3s ease, background-color 0.3s ease, transform 0.3s ease;
            z-index: 50;
            overflow-y: auto; /* Enable scrolling for long menus */
            overflow-x: hidden; /* Hide horizontal scrollbar */
            padding: 20px 0; /* Apply padding here */
            box-sizing: border-box; /* Include padding in width calculation */
            /* Apply glass effect */
            backdrop-filter: blur(12px); /* Increased blur */
            -webkit-backdrop-filter: blur(12px);
            border-right: 1px solid var(--sidebar-border); /* Use semi-transparent border */
            box-shadow: var(--sidebar-shadow);
            display: flex; /* Ensure flex properties are applied */
            flex-direction: column; /* Ensure flex properties are applied */
        }

        .sidebar.expanded {
            width: 250px; /* Expanded width */
        }

        .sidebar nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar nav ul li {
            margin-bottom: 5px;
        }

        .sidebar nav ul li a,
        .sidebar nav ul li button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 12px 20px;
            color: var(--sidebar-item-text);
            text-decoration: none;
            font-size: 1em;
            font-weight: 500;
            border: none;
            background: none;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s ease, color 0.2s ease;
            border-radius: 8px;
            overflow: hidden;
        }

        .sidebar nav ul li a i,
        .sidebar nav ul li button i {
            margin-right: 15px;
            color: var(--sidebar-item-icon);
            transition: color 0.2s ease, margin-right 0.3s ease;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .sidebar:not(.expanded) .sidebar nav ul li a span,
        .sidebar:not(.expanded) .sidebar nav ul li button span {
            opacity: 0;
            width: 0;
            white-space: nowrap;
            transition: opacity 0.3s ease, width 0.3s ease;
        }

        .sidebar:not(.expanded) .sidebar nav ul li a i,
        .sidebar:not(.expanded) .sidebar nav ul li button i {
            margin-right: 0;
            justify-content: center;
        }

        .sidebar nav ul li a:hover,
        .sidebar nav ul li button:hover {
            background-color: var(--sidebar-item-bg-hover);
        }

        .sidebar nav ul li.active > a,
        .sidebar nav ul li.active > button {
            background-color: var(--sidebar-active-item-bg);
            color: var(--sidebar-active-item-text);
        }

        .sidebar nav ul li.active > a i,
        .sidebar nav ul li.active > button i {
            color: var(--sidebar-active-item-icon);
        }

        /* Sub-menu styling */
        .sidebar nav ul ul {
            padding-left: 40px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 0 0 8px 8px;
        }

        body.light-mode .sidebar nav ul ul {
            background-color: rgba(0, 0, 0, 0.02);
        }

        .sidebar nav ul li.expanded > ul {
            max-height: 500px;
        }

        .sidebar nav ul li .sub-menu-toggle {
            margin-left: auto;
            font-size: 0.8em;
            transition: transform 0.2s ease;
        }

        .sidebar nav ul li.expanded .sub-menu-toggle {
            transform: rotate(90deg);
        }

        /* Theme toggle button in sidebar */
        #theme-toggle {
            margin-top: auto;
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 700;
            margin-left: 20px;
            margin-right: 20px;
            transition: background-color 0.3s ease, transform 0.1s ease, opacity 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .sidebar:not(.expanded) #theme-toggle {
            opacity: 0;
            pointer-events: none;
            width: 0;
            padding: 0;
            margin-left: 0;
            margin-right: 0;
        }

        #theme-toggle:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        #theme-toggle:active {
            transform: translateY(0);
        }

        /* Sidebar Toggle Button for Desktop */
        .sidebar-toggle-desktop {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: var(--bg-card);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.15s ease, box-shadow 0.3s ease;
            box-shadow: var(--box-shadow);
            z-index: 51;
            display: none;
        }

        .sidebar-toggle-desktop:hover {
            background-color: var(--primary-color);
            color: white;
        }

        /* User Info in Sidebar */
        .user-info {
            padding: 15px 20px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            border-bottom: 1px solid var(--sidebar-border);
            text-align: left;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .sidebar:not(.expanded) .user-info {
            opacity: 0;
            height: 0;
            overflow: hidden;
            padding: 0;
            margin: 0;
            border: none;
        }

        .user-info h4 {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .user-info .user-id {
            font-size: 0.85em;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .pro-badge {
            background-color: gold;
            color: #333;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.7em;
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
        }

        .pro-badge.active {
            display: inline-block;
        }

        #toggle-pro-button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .sidebar:not(.expanded) #toggle-pro-button {
            opacity: 0;
            pointer-events: none;
            width: 0;
            padding: 0;
            margin: 0;
        }

        #toggle-pro-button:hover {
            background-color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* Main content area */
        .main-content {
            margin-left: 60px; /* Space for the collapsed sidebar */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed to flex-start to allow scrolling from top */
            padding: 20px;
            box-sizing: border-box;
            transition: margin-left 0.3s ease;
            width: calc(100% - 60px);
            overflow-y: auto; /* Allow main content to scroll if needed */
            min-height: calc(100vh - 60px); /* Base for desktop: 100vh - top menu button area */
            scroll-behavior: smooth; /* Added for smooth scrolling */
        }

        .sidebar.expanded + .main-content {
            margin-left: 250px; /* Space for the expanded sidebar */
            width: calc(100% - 250px);
        }

        /* Page containers */
        .page-content {
            width: 100%;
            max-width: 800px; /* Max width for content pages */
            background-color: var(--bg-card);
            border-radius: 20px;
            padding: 25px;
            box-sizing: border-box;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 20px;
            /* Remove flex-grow and justify-content from here to allow content to push down */
            /* flex-grow: 1; */
            /* justify-content: center; */
            min-height: calc(100vh - 100px); /* Ensure page content is tall enough to allow scrolling if needed */
            margin-bottom: 20px; /* Space before the ad or end of content */
        }

        .page-content.active {
            display: flex; /* Show active page */
        }

        #home-page h1 {
            font-size: 2.8em;
            font-weight: 800;
            color: var(--primary-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
        }

        #home-page h3 {
            font-size: 1.8em;
            color: var(--text-light);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        #home-page p {
            font-size: 1.1em;
            line-height: 1.6;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        #home-page ul {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
            text-align: left;
            width: 100%;
            max-width: 400px;
        }

        #home-page ul li {
            margin-bottom: 8px;
            color: var(--text-light);
            display: flex;
            align-items: center;
        }

        #home-page ul li::before {
            content: "\2022"; /* Bullet point */
            color: var(--primary-color);
            font-weight: bold;
            display: inline-block;
            width: 1em;
            margin-left: -1em;
        }

        #home-page .button {
            margin-top: 20px;
        }

        #game-selection-page h2 {
            font-size: 2.5em;
            font-weight: 800;
            color: var(--primary-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
        }

        #game-selection-page .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Responsive grid */
            gap: 20px;
            width: 100%;
            max-width: 700px; /* Adjust max-width for the grid */
            margin-top: 20px;
        }

        .game-card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            text-decoration: none; /* Ensure it looks like a card, not a link */
            color: var(--text-light);
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            background-color: rgba(45, 55, 72, 0.5); /* Slightly darker on hover */
        }

        body.light-mode .game-card:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }

        .game-card i {
            font-size: 3em;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .game-card h3 {
            font-size: 1.1em;
            font-weight: 700;
            margin: 0;
            color: var(--text-light);
        }

        /* Styles for the dynamically loaded Tic Tac Toe game */
        #dynamic-game-container {
            width: 100%;
            height: 100%; /* Changed from min-height */
            max-width: none; /* Removed max-width constraint */
            display: flex;
            flex-direction: column; /* Ensure content stacks vertically */
            justify-content: center;
            align-items: center;
            /* Removed min-height: 400px; */
        }

        /* Specific styles for Flappy Bird game elements (when active) */
        .flappy-bird-game-elements {
            display: none; /* Hidden by default, shown when Flappy Bird is active */
        }

        #game-page.flappy-bird-active .flappy-bird-game-elements {
            display: flex; /* Or block, based on element type */
        }

        /* Flappy Bird Game Container */
        #game-page .game-container {
            position: relative;
            background-color: var(--bg-card); /* Semi-transparent for glass */
            border-radius: 20px;
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            width: 100%;
            max-width: 550px;
            box-sizing: border-box;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
            transition: transform 0.3s ease, width 0.3s ease, height 0.3s ease; /* Add transition for rotation */
        }

        canvas {
            background-color: var(--sky-blue); /* Controlled by JS/CSS variables */
            border: 3px solid var(--border-color);
            border-radius: 15px;
            display: block;
            width: 100%; /* Set width to 100% */
            height: 100%; /* Set height to 100% */
            touch-action: manipulation;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        /* Ground styling */
        .ground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background-color: var(--ground-brown); /* Controlled by JS/CSS variables */
            border-top: 3px solid var(--border-color);
            border-radius: 0 0 15px 15px;
            z-index: 5;
        }

        #score-display {
            position: absolute;
            top: 35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3.2em;
            font-weight: 800;
            color: white;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.6);
            z-index: 10;
            transition: transform 0.1s ease-out, font-size 0.1s ease-out;
        }

        #score-display.score-pop {
            transform: translateX(-50%) scale(1.1);
            font-size: 3.5em;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Still mostly opaque for readability */
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            text-align: center;
            gap: 15px;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.9);
            transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
            /* Apply glass effect to game over screen too */
            backdrop-filter: blur(8px); /* Slightly less blur for readability */
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        #game-over-screen.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }

        #game-over-screen h2 {
            font-size: 2.8em;
            font-weight: 800;
            color: var(--danger-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            margin-bottom: 5px;
            animation: bounceIn 0.8s ease-out;
        }

        #final-score {
            font-size: 2em;
            font-weight: 700;
            color: var(--warning-color);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        #high-score {
            font-size: 1.1em;
            color: var(--text-light);
            margin-top: 5px;
        }

        .button {
            padding: 14px 30px;
            font-size: 1.2em;
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.15s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            text-decoration: none;
            display: inline-block;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .button-primary {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .button-primary:hover {
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 0 15px var(--primary-color);
        }

        .button-primary:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Bottom Navbar Styling */
        .bottom-navbar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px; /* Height of the bottom navbar */
            display: none; /* Hidden by default */
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 100; /* Ensure it's on top */
            background-color: var(--bottom-nav-bg);
            border-top: 1px solid var(--bottom-nav-border);
            box-shadow: var(--bottom-nav-shadow);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .bottom-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            padding: 5px 0;
            color: var(--bottom-nav-item-color);
            font-size: 0.8em;
            text-decoration: none;
            transition: color 0.3s ease, background-color 0.3s ease, transform 0.1s ease;
            border-radius: 10px;
            cursor: pointer;
            position: relative; /* For active indicator */
        }

        .bottom-nav-item i {
            font-size: 1.4em;
            margin-bottom: 4px;
            transition: color 0.3s ease;
        }

        .bottom-nav-item .icon-background {
            /* This div wraps the icon to allow for the active state background */
            width: 48px; /* Size of the active circle */
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        .bottom-nav-item.active .icon-background {
            background-color: var(--bottom-nav-active-bg);
            color: var(--bottom-nav-active-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .bottom-nav-item.active i {
            color: var(--bottom-nav-active-color);
            z-index: 1; /* Ensure icon is above background */
        }

        .bottom-nav-item span {
            margin-top: 2px;
            font-size: 0.75em;
            font-weight: 600;
            white-space: nowrap;
            transition: color 0.3s ease;
        }

        .bottom-nav-item.active span {
            color: var(--bottom-nav-active-color);
        }

        /* Pre-game countdown styling */
        #countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6em;
            font-weight: 800;
            color: white;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.7);
            z-index: 30;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #countdown-display.active {
            opacity: 1;
            visibility: visible;
            animation: countdownPop 0.8s ease-out forwards;
        }

        @keyframes countdownPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Level Up message styling */
        #level-up-display {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: 800;
            color: var(--primary-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 40;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        #level-up-display.active {
            opacity: 1;
            visibility: visible;
            animation: levelUpFade 2s forwards;
        }

        @keyframes levelUpFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        /* Device rotation hint */
        #rotation-hint {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            text-align: center;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        #rotation-hint.active {
            opacity: 1;
            visibility: visible;
        }

        #rotation-hint i {
            font-size: 3em;
            margin-bottom: 20px;
            animation: rotateIcon 2s infinite ease-in-out;
        }

        #rotation-hint .button-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        #rotation-hint .button {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 700;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        #rotation-hint .button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        #rotation-hint .button:active {
            transform: translateY(0);
        }

        @keyframes rotateIcon {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(0deg); }
        }

        /* Game Start Overlay */
        #game-start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.8em;
            font-weight: 700;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            z-index: 25; /* Above canvas, below countdown/game over */
            opacity: 1;
            visibility: visible;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        #game-start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #game-start-overlay p {
            margin: 0;
            padding: 10px;
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
            gap: 15px;
            margin-top: 20px; /* Space between canvas and buttons */
            width: 100%;
            max-width: 550px; /* Match game container max-width */
        }

        .game-controls .button {
            flex: 1 1 auto; /* Allow buttons to grow and shrink */
            min-width: 120px; /* Minimum width for buttons */
            padding: 12px 20px;
            font-size: 1.1em;
        }

        /* Ad Placement Styling */
        .ad-placement {
            width: 100%;
            max-width: 728px; /* Typical leaderboard ad width */
            min-height: 90px; /* Typical leaderboard ad height */
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.1em;
            color: var(--text-muted);
            margin-top: 40px; /* Space above the ad */
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: var(--box-shadow);
            overflow: hidden; /* Ensure ad content doesn't overflow */
            margin-left: auto; /* Explicitly center */
            margin-right: auto; /* Explicitly center */
        }

        /* Specific ad sizes for different pages/types (adjust as needed for actual ads) */
        #game-ad {
            max-width: 300px; /* Smaller ad for game page */
            min-height: 250px; /* Medium rectangle */
            margin-top: 20px; /* Closer to game controls */
        }

        #game-selection-ad {
            max-width: 336px; /* Another common ad size */
            min-height: 280px;
        }

        /* Live Updates Section Styling */
        .live-updates-section {
            width: 100%;
            max-width: 800px;
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            margin-top: 40px;
            text-align: left;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: var(--box-shadow);
        }

        .live-updates-section h3 {
            font-size: 1.5em;
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 15px;
        }

        .live-updates-message {
            font-size: 1em;
            color: var(--text-light);
            margin-bottom: 15px;
            padding: 10px 15px;
            background-color: rgba(99, 102, 241, 0.1); /* Light primary color background */
            border-left: 4px solid var(--primary-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .live-updates-message:empty::before {
            content: "No recent updates.";
            color: var(--text-muted);
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            /* Show desktop toggle button */
            .sidebar-toggle-desktop {
                display: block;
            }
            /* Hide mobile toggle button */
            .menu-toggle-button {
                display: none;
            }
            /* Hide bottom navbar on desktop */
            .bottom-navbar-container {
                display: none;
            }
            /* Reset main-content padding for desktop */
            .main-content {
                padding-bottom: 20px; /* Original padding */
                min-height: calc(100vh - 60px); /* Adjust min-height for desktop */
            }
            #rotation-hint {
                display: none; /* Hide on desktop */
            }
            .game-page .game-container {
                /* Center the game container on desktop */
                margin: auto; /* Auto margins for horizontal centering */
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 0; /* Collapse sidebar by default on smaller screens */
                transform: translateX(-100%); /* Hide it off-screen */
                padding: 0;
            }

            .sidebar.active {
                width: 250px; /* Expand when active */
                transform: translateX(0%);
                padding: 20px 0;
            }

            .main-content {
                margin-left: 0; /* No margin when sidebar is collapsed */
                width: 100%; /* Take full width */
                padding-top: 80px; /* Space for fixed menu button at top */
                padding-bottom: 90px; /* Space for fixed bottom navbar */
                min-height: calc(100vh - 80px - 90px); /* Adjusted min-height for mobile fixed elements */
                justify-content: flex-start; /* Ensure content starts from top for scrolling */
            }

            .menu-toggle-button {
                display: block; /* Show hamburger menu button */
                position: fixed;
                top: 20px;
                left: 20px;
                z-index: 60; /* Above sidebar */
                background-color: var(--bg-card);
                color: var(--text-light);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 10px 15px;
                cursor: pointer;
                box-shadow: var(--box-shadow);
                transition: background-color 0.3s ease, color 0.3s ease;
            }

            .menu-toggle-button:hover {
                background-color: var(--primary-color);
                color: white;
            }

            /* Game container positioning on mobile */
            .game-page .game-container {
                /* Remove absolute positioning. Rely on flexbox centering from .page-content */
                position: static;
                top: auto;
                left: auto;
                transform: none; /* Reset any previous transforms */
                transform-origin: center center; /* Default */
                margin-top: 0; /* Reset margin from previous versions */
                margin-bottom: 0; /* Reset margin from previous versions */

                width: 90vw; /* User requested 90% width */
                height: auto; /* Let height be determined by aspect ratio */
                max-width: calc(100vw - (2 * 20px)); /* Ensure it doesn't exceed main-content width */
                /* Adjusted max-height to account for new game controls and padding */
                max-height: calc(100vh - 80px - 90px - 20px - 80px); /* 100vh - top menu - bottom nav - main-content vertical padding - estimated game controls height */
                
                /* Ensure content within game-container is centered if it has flex properties */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            /* Show bottom navbar on mobile */
            .bottom-navbar-container {
                display: flex;
            }
        }

        @media (max-width: 768px) and (orientation: portrait) {
            .game-page .game-container.rotated {
                transform: rotate(90deg);
                /* When rotated, visual width is its height, visual height is its width */
                height: auto; /* Let height be determined by aspect ratio */
                width: 90vw; /* Still aim for 90vw for the rotated 'width' */
                aspect-ratio: var(--game-canvas-height) / var(--game-canvas-width); /* Invert aspect ratio */
                max-height: calc(100vh - 80px - 90px - 20px - 80px); /* Still constrain by available vertical space */
            }

            .game-page .game-container.no-rotate {
                transform: rotate(0deg); /* Explicitly no rotation */
                width: 90vw; /* Maximize width in portrait */
                height: auto; /* Let height adjust dynamically */
                aspect-ratio: var(--game-canvas-width) / var(--game-canvas-height); /* Maintain original aspect ratio */
                max-height: calc(100vh - 80px - 90px - 20px - 80px); /* Limit total height considering top/bottom bars */
            }

            /* For very small screens, adjust padding to maximize game area */
            @media (max-width: 400px) {
                .main-content {
                    padding-left: 10px; /* Reduce padding for tiny screens */
                    padding-right: 10px;
                    padding-top: 70px; /* Adjust top padding */
                    padding-bottom: 80px; /* Adjust bottom padding */
                }
                .game-page .game-container {
                    width: 95vw; /* Slightly more width for tiny screens */
                    max-height: calc(100vh - 70px - 80px - 10px - 70px); /* Adjusted for new padding and smaller controls */
                }
                .game-page .game-container.rotated {
                    height: auto;
                    width: 95vw;
                    max-height: calc(100vh - 70px - 80px - 10px - 70px);
                }
                .game-page .game-container.no-rotate {
                    width: 95vw;
                    max-height: calc(100vh - 70px - 80px - 10px - 70px);
                }
            }
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
                width: 100%;
                border-radius: 10px; /* Smaller radius for smaller screens */
                gap: 15px;
            }
            canvas {
                height: 500px; /* Increased height for mobile portrait when not rotated */
                border-radius: 10px;
            }
            #score-display {
                font-size: 2.8em;
                top: 25px;
            }
            #score-display.score-pop {
                transform: translateX(-50%) scale(1.1);
                font-size: 3.1em;
            }
            #game-over-screen {
                font-size: 1.1em;
                gap: 15px;
            }
            #game-over-screen h2 {
                font-size: 2.5em;
            }
            #final-score {
                font-size: 1.8em;
            }
            #high-score {
                font-size: 1.1em;
            }
            .button {
                padding: 12px 25px;
                font-size: 1.1em;
                border-radius: 8px;
            }
            .bottom-navbar-container {
                height: 80px; /* Slightly taller for better touch targets */
            }
            .bottom-nav-item i {
                font-size: 1.6em;
            }
            .bottom-nav-item.active .icon-background {
                width: 55px;
                height: 55px;
            }
            .bottom-nav-item span {
                font-size: 0.8em;
            }
        }

        @media (max-width: 400px) {
            .game-container {
                padding: 15px;
                width: 100%;
                border-radius: 10px; /* Smaller radius for smaller screens */
                gap: 15px;
            }
            canvas {
                height: 420px; /* Further increased height for smaller mobile when not rotated */
                border-radius: 10px;
            }
            #score-display {
                font-size: 2.2em;
            }
            #score-display.score-pop {
                font-size: 2.5em;
            }
            #game-over-screen h2 {
                font-size: 2em;
            }
            #final-score {
                font-size: 1.5em;
            }
            #high-score {
                font-size: 0.9em;
            }
            .button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .bottom-navbar-container {
                height: 70px;
            }
            .bottom-nav-item i {
                font-size: 1.3em;
            }
            .bottom-nav-item.active .icon-background {
                width: 48px;
                height: 48px;
            }
            .bottom-nav-item span {
                font-size: 0.7em;
            }
        }

        /* Whack-a-Mole Specific Styles */
        .whack-a-mole-game {
            width: 100%; /* Changed from max-width */
            height: 100%; /* Added */
            padding: 20px;
            background-color: var(--bg-card);
            border-radius: 20px;
            box-shadow: var(--box-shadow);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            margin-left: auto; /* Explicitly center */
            margin-right: auto; /* Explicitly center */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centers horizontally */
            justify-content: center; /* Centers vertically */
        }

        .whack-a-mole-game h1 {
            font-size: 2.5em;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            width: 100%; /* Ensure it takes full width to distribute items */
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-light);
        }

        .game-stats div span {
            color: var(--secondary-color);
            font-size: 1.5em;
            font-weight: 800;
            margin-left: 5px;
        }

        .mole-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            width: 100%; /* Changed from max-width */
            max-width: 500px; /* Slightly increased max-width */
            aspect-ratio: 1 / 1;
            margin: 0 auto;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            position: relative;
            flex-grow: 1; /* Allow it to grow and take available space */
            box-sizing: border-box;
        }

        .hole {
            width: 100%;
            height: 100%;
            background-color: #5a3a2b; /* Brown soil */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Moles pop from bottom */
            overflow: hidden;
            position: relative;
            border: 5px solid #3a251c; /* Darker soil border */
            box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.4), 0 2px 5px rgba(0, 0, 0, 0.3);
            /* 3D effect for holes */
            transform-style: preserve-3d;
            transform: perspective(200px) rotateX(10deg);
            transition: transform 0.1s ease-out;
        }

        .hole:active {
            transform: perspective(200px) rotateX(0deg); /* Flatten on click */
        }

        .mole {
            width: 80%;
            height: 80%;
            background-color: #8B4513; /* SaddleBrown */
            border-radius: 50%;
            position: absolute;
            bottom: -100%; /* Start hidden below the hole */
            transition: bottom 0.2s ease-out, background-color 0.1s ease, transform 0.1s ease;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em; /* Mole emoji size */
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
            border: 3px solid #6b3e1a;
            user-select: none; /* Prevent text selection on rapid clicks */
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        .mole.up {
            bottom: 0; /* Pop up */
        }

        .mole.hit {
            transform: scale(0.9);
        }

        /* Specific mole type colors */
        .mole[data-type="NORMAL"] { background-color: #8B4513; }
        .mole[data-type="NORMAL"].hit { background-color: var(--success-color); } /* Green on hit */

        .mole[data-type="FAST"] { background-color: #FFD700; color: #333; } /* Gold */
        .mole[data-type="FAST"].hit { background-color: #4A90E2; } /* Blue on hit */

        .mole[data-type="BOMB"] { background-color: #333333; } /* Dark Gray */
        .mole[data-type="BOMB"].hit { background-color: var(--danger-color); } /* Red on hit */


        /* Score feedback animation */
        .score-feedback {
            position: absolute;
            font-size: 1.5em;
            font-weight: 800;
            color: var(--success-color); /* Default green for positive score */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            pointer-events: none; /* Allow clicks to pass through */
            animation: scorePop 1s forwards;
            white-space: nowrap;
            z-index: 10; /* Above moles */
        }

        .score-feedback.negative {
            color: var(--danger-color); /* Red for negative score */
        }

        @keyframes scorePop {
            0% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, -50px); opacity: 0; }
        }


        .whack-a-mole-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .whack-a-mole-game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            text-align: center;
            gap: 15px;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.9);
            transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        .whack-a-mole-game-over.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }

        .whack-a-mole-game-over h2 {
            font-size: 2.8em;
            font-weight: 800;
            color: var(--danger-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            margin-bottom: 5px;
        }

        .whack-a-mole-game-over p {
            font-size: 1.5em;
            color: var(--warning-color);
        }

        /* Space Miner specific styles */
        .space-miner-game .game-canvas {
            background-color: #0d1117; /* Deep space background */
            border: 3px solid #4a0e6e; /* Purple border */
            border-radius: 15px;
            touch-action: none; /* Prevent scrolling/zooming */
        }

        .space-miner-game .game-stats {
            margin-top: 15px;
            font-size: 1.3em;
            color: #a78bfa; /* Violet */
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .space-miner-game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            text-align: center;
            gap: 15px;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.9);
            transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        .space-miner-game-over.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }

        .space-miner-game-over h2 {
            font-size: 2.8em;
            font-weight: 800;
            color: #f59e0b; /* Amber */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            margin-bottom: 5px;
        }

        .space-miner-game-over p {
            font-size: 1.5em;
            color: #e2e8f0;
        }

        /* City Runner specific styles */
        .city-runner-game .game-canvas {
            background: linear-gradient(to bottom, #87CEEB, #A0D2EB); /* Sky blue gradient */
            border: 3px solid #666;
            border-radius: 15px;
            touch-action: none; /* Prevent scrolling/zooming */
        }

        .city-runner-game .game-stats {
            margin-top: 15px;
            font-size: 1.3em;
            color: #2ecc71; /* Green for city theme */
            font-weight: 700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .city-runner-game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            text-align: center;
            gap: 15px;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.9);
            transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        .city-runner-game-over.active {
            opacity: 1;
            visibility: visible;
            transform: scale(1);
        }

        .city-runner-game-over h2 {
            font-size: 2.8em;
            font-weight: 800;
            color: #e74c3c; /* Red for game over */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            margin-bottom: 5px;
        }

        .city-runner-game-over p {
            font-size: 1.5em;
            color: #e2e8f0;
        }

        @media (max-width: 400px) {
            .whack-a-mole-game {
                padding: 15px;
            }
            .whack-a-mole-game h1 {
                font-size: 2em;
            }
            .game-stats {
                font-size: 1em;
            }
            .game-stats div span {
                font-size: 1.2em;
            }
            .mole-grid {
                max-width: 300px;
                gap: 10px;
            }
            .mole {
                font-size: 2em;
            }
            .whack-a-mole-game-over h2 {
                font-size: 2.2em;
            }
            .whack-a-mole-game-over p {
                font-size: 1.2em;
            }
        }

        /* Smart Notepad Styles */
        .notepad-container {
            width: 100%;
            max-width: 800px;
            background-color: var(--notepad-bg);
            border-radius: 20px;
            padding: 25px;
            box-sizing: border-box;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--notepad-border);
            box-shadow: var(--box-shadow);
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: left;
        }

        .notepad-container h1 {
            font-size: 2.5em;
            font-weight: 800;
            color: var(--primary-color);
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
            text-align: center;
        }

        .notepad-section {
            background-color: var(--bg-card);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .notepad-section h2 {
            font-size: 1.8em;
            color: var(--text-light);
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-light);
        }

        .form-group input[type="text"],
        .form-group select,
        .form-group textarea {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-light);
            font-size: 1em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .form-group input[type="text"]:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .tag-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 15px;
        }

        .tag-group label {
            display: flex;
            align-items: center;
            background-color: var(--tag-bg);
            color: var(--tag-text);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .tag-group input[type="checkbox"] {
            margin-right: 8px;
            appearance: none; /* Hide default checkbox */
            width: 16px;
            height: 16px;
            border: 2px solid var(--tag-text);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .tag-group input[type="checkbox"]:checked {
            background-color: var(--tag-text);
            border-color: var(--tag-text);
        }

        .tag-group input[type="checkbox"]:checked::after {
            content: '\2713'; /* Checkmark */
            font-size: 12px;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .tag-group label:hover {
            transform: translateY(-2px);
            background-color: rgba(99, 102, 241, 0.3);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .button-group .button {
            padding: 10px 20px;
            font-size: 1em;
            flex-grow: 1;
            min-width: 100px;
        }

        /* Note List */
        #notes-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .note-card {
            background-color: var(--bg-card);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .note-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .note-card.archived {
            opacity: 0.6;
            text-decoration: line-through;
            filter: grayscale(80%);
        }

        .note-card h3 {
            font-size: 1.4em;
            color: var(--primary-color);
            margin: 0 0 5px 0;
            word-wrap: break-word;
        }

        .note-card .note-meta {
            font-size: 0.85em;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .note-card .note-subject {
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            display: inline-block;
            /* Default subject color, overridden by specific classes */
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-light);
        }

        /* Subject specific colors */
        .note-card.subject-math .note-subject { background-color: var(--subject-math); color: white; }
        .note-card.subject-physics .note-subject { background-color: var(--subject-physics); color: white; }
        .note-card.subject-coding .note-subject { background-color: var(--subject-coding); color: #333; }
        .note-card.subject-chemistry .note-subject { background-color: var(--subject-chemistry); color: white; }
        .note-card.subject-history .note-subject { background-color: var(--subject-history); color: #333; }
        .note-card.subject-literature .note-subject { background-color: var(--subject-literature); color: white; }
        .note-card.subject-biology .note-subject { background-color: var(--subject-biology); color: white; }
        .note-card.subject-art .note-subject { background-color: var(--subject-art); color: white; }
        .note-card.subject-other .note-subject { background-color: var(--subject-other); color: #333; }

        .note-card .note-content {
            font-size: 1em;
            color: var(--text-light);
            line-height: 1.5;
            flex-grow: 1;
            word-wrap: break-word;
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            text-align: left;
        }

        .note-card .note-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .note-card .note-tag {
            background-color: var(--tag-bg);
            color: var(--tag-text);
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.75em;
            font-weight: 500;
        }

        .note-card .note-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        .note-card .note-actions button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .note-card .note-actions button:hover {
            background-color: var(--primary-color);
            transform: translateY(-1px);
        }

        .note-card .note-actions button.delete-btn {
            background-color: var(--danger-color);
        }
        .note-card .note-actions button.delete-btn:hover {
            background-color: #c0392b;
        }

        /* Checklist styling within note content */
        .note-checklist {
            list-style: none;
            padding: 0;
            margin: 10px 0 0 0;
            border-top: 1px solid var(--checklist-border);
            padding-top: 10px;
        }

        .note-checklist li {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            background-color: var(--checklist-bg);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--checklist-border);
            transition: background-color 0.2s ease;
        }

        .note-checklist li.completed {
            background-color: var(--checklist-checked-bg);
            text-decoration: line-through;
            color: var(--checklist-checked-text);
        }

        .note-checklist li input[type="checkbox"] {
            margin-right: 10px;
            min-width: 18px; /* Ensure clickable area */
            min-height: 18px;
            cursor: pointer;
        }

        /* Filters section */
        .filters-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .filters-section select,
        .filters-section button {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--text-light);
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .filters-section select:hover,
        .filters-section button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }

        .filters-section button.active-filter {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Progress Tracker */
        .progress-tracker {
            text-align: center;
            margin-bottom: 20px;
        }

        .progress-tracker h2 {
            margin-bottom: 10px;
        }

        .progress-bar-container {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background-color: var(--progress-bar-bg);
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: var(--progress-bar-fill);
            border-radius: 10px;
            transition: width 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.8em;
        }

        /* Thought Dump */
        .thought-dump-section textarea {
            width: calc(100% - 20px);
            min-height: 120px;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-light);
            font-size: 1em;
            resize: vertical;
        }

        .thought-dump-section .button {
            margin-top: 10px;
        }

        /* Focus Mode */
        .notepad-container.focus-mode #add-note-section,
        .notepad-container.focus-mode .filters-section,
        .notepad-container.focus-mode .progress-tracker,
        .notepad-container.focus-mode .thought-dump-section {
            display: none;
        }

        .notepad-container.focus-mode #notes-list {
            display: block; /* Change to block to stack notes */
        }

        .notepad-container.focus-mode .note-card {
            margin-bottom: 20px; /* Space between notes in focus mode */
            max-width: 100%; /* Take full width */
        }

        .notepad-container.focus-mode .note-card:not(.focused-note) {
            display: none; /* Hide non-focused notes */
        }

        .notepad-container .focus-mode-toggle-button {
            margin-top: 20px;
            width: auto; /* Allow button to size naturally */
            align-self: center; /* Center the button */
        }

        /* Export/Backup Buttons */
        .export-backup-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .export-backup-section .button {
            flex-grow: 1;
            min-width: 150px;
        }

        @media (max-width: 600px) {
            .notepad-container {
                padding: 15px;
            }
            .notepad-container h1 {
                font-size: 2em;
            }
            .notepad-section {
                padding: 15px;
            }
            .notepad-section h2 {
                font-size: 1.5em;
            }
            .form-group input[type="text"],
            .form-group select,
            .form-group textarea {
                width: calc(100% - 16px); /* Adjust padding */
            }
            .tag-group label {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            .button-group .button {
                min-width: unset;
                flex-basis: 48%; /* Two buttons per row */
            }
            #notes-list {
                grid-template-columns: 1fr; /* Single column on small screens */
            }
            .note-card {
                padding: 15px;
            }
            .note-card h3 {
                font-size: 1.2em;
            }
            .note-card .note-actions button {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            .filters-section {
                flex-direction: column;
                align-items: center;
            }
            .filters-section select,
            .filters-section button {
                width: 100%;
                max-width: 300px;
            }
            .progress-bar-container {
                width: 95%;
            }
            .export-backup-section .button {
                flex-basis: 100%;
            }
        }
    </style>
</head>
<body>
    <button class="menu-toggle-button" id="menuToggleButton"><i class="fas fa-bars"></i></button>

    <div class="sidebar glass-effect" id="sidebar">
        <button class="sidebar-toggle-desktop" id="sidebarToggleDesktop"><i class="fas fa-chevron-left"></i></button>
        <div class="user-info">
            <h4><span id="pro-badge" class="pro-badge">Pro</span></h4>
            <button id="toggle-pro-button">Toggle Pro Status</button>
        </div>
        <nav>
            <ul>
                <li class="active"><a href="#" data-page="smart-notepad-page"><i class="fas fa-book"></i> <span>Smart Notepad</span></a></li>
                <li><a href="#" data-page="game-selection-page"><i class="fas fa-gamepad"></i> <span>Play Game</span></a></li>
                <li><a href="#"><i class="fas fa-eye"></i> <span>View Site</span></a></li>
                <li><a href="#"><i class="fas fa-store"></i> <span>Marketplace</span></a></li>
                <li id="postsMenuItem">
                    <button class="menu-item-toggle"><i class="fas fa-newspaper"></i> <span>Posts</span> <i class="fas fa-chevron-right sub-menu-toggle"></i></button>
                    <ul>
                        <li><a href="#"><i class="fas fa-plus"></i> <span>Create Post</span></a></li>
                        <li><a href="#"><i class="fas fa-file-alt"></i> <span>Drafts</span> <span style="margin-left: auto;">10</span></a></li>
                        <li><a href="#"><i class="fas fa-clock"></i> <span>Scheduled</span> <span style="margin-left: auto;">2</span></a></li>
                        <li><a href="#"><i class="fas fa-check-circle"></i> <span>Published</span> <span style="margin-left: auto;">28</span></a></li>
                    </ul>
                </li>
                <li><a href="#"><i class="fas fa-file"></i> <span>Pages</span></a></li>
                <li><a href="#"><i class="fas fa-chart-line"></i> <span>Performance</span></a></li>
                <li><a href="#"><i class="fas fa-tags"></i> <span>Tags</span></a></li>
                <li><a href="#"><i class="fas fa-users"></i> <span>Members</span></a></li>
                <li><a href="#"><i class="fas fa-paint-brush"></i> <span>Design</span></a></li>
            </ul>
        </nav>
        <button id="theme-toggle">Toggle Dark/Light Mode</button>
    </div>

    <div class="main-content">
        <div id="smart-notepad-page" class="page-content active">
            <div class="notepad-container glass-effect" id="notepad-container">
                <h1> Smart Notepad</h1>

                <div id="add-note-section" class="notepad-section">
                    <h2> Add New Note</h2>
                    <div class="form-group">
                        <label for="note-title">Title:</label>
                        <input type="text" id="note-title" placeholder="e.g., Quantum Physics Basics">
                    </div>
                    <div class="form-group">
                        <label for="note-subject">Subject:</label>
                        <input type="text" id="note-subject" list="subject-suggestions" placeholder="e.g., Physics">
                        <datalist id="subject-suggestions"></datalist>
                    </div>
                    <div class="form-group">
                        <label for="note-content">Content:</label>
                        <textarea id="note-content" placeholder="Start writing your notes here... Use [ ] for checklist items."></textarea>
                    </div>
                    <div class="form-group">
                        <label>Tags:</label>
                        <div class="tag-group">
                            <label><input type="checkbox" data-tag="Important">  Important</label>
                            <label><input type="checkbox" data-tag="Revise">  Revise</label>
                            <label><input type="checkbox" data-tag="To-Do">  To-Do</label>
                            <label><input type="checkbox" data-tag="Priority">  Priority</label>
                            <label><input type="checkbox" data-tag="Confusing">  Confusing</label>
                        </div>
                    </div>
                    <div class="button-group">
                        <button id="add-note-button" class="button button-primary">Add Note</button>
                        <button id="clear-form-button" class="button button-primary">Clear Form</button>
                    </div>
                </div>

                <div id="progress-tracker-section" class="notepad-section progress-tracker">
                    <h2> Progress Tracker</h2>
                    <p>You've completed <span id="completed-tasks-percentage">0%</span> of your study tasks!</p>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill" id="progress-bar-fill"></div>
                    </div>
                </div>

                <div id="thought-dump-section" class="notepad-section thought-dump-section">
                    <h2> Thought Dump</h2>
                    <textarea id="thought-dump-textarea" placeholder="Unload random thoughts here..."></textarea>
                    <button id="clear-thought-dump-button" class="button button-primary">Clear Head</button>
                </div>

                <div id="filters-section" class="notepad-section filters-section">
                    <h2> Smart Filters</h2>
                    <select id="filter-subject">
                        <option value="all">All Subjects</option>
                    </select>
                    <select id="sort-date">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                    </select>
                    <button id="filter-today" class="button button-primary">Today</button>
                    <button id="filter-important" class="button button-primary">Important</button>
                    <button id="filter-revise" class="button button-primary">Revise</button>
                    <button id="filter-todo-pending" class="button button-primary">To-Do Pending</button>
                    <button id="filter-archived" class="button button-primary">Archived</button>
                    <button id="clear-filters-button" class="button button-primary">Clear Filters</button>
                </div>
                
                <button id="focus-mode-toggle-button" class="button button-primary focus-mode-toggle-button">Enter Focus Mode</button>

                <div id="notes-list" class="notepad-section">
                    <h2> Your Notes</h2>
                    <p id="no-notes-message" style="text-align: center; color: var(--text-muted);">No notes yet. Add one above!</p>
                </div>

                <div id="export-backup-section" class="notepad-section export-backup-section">
                    <h2> Data Management</h2>
                    <button id="export-note-button" class="button button-primary">Export Selected Note (.txt)</button>
                    <button id="backup-all-notes-button" class="button button-primary">Backup All Notes (.json)</button>
                </div>
            </div>
        </div>

        <div id="game-selection-page" class="page-content">
            <h2>Choose Your Game!</h2>
            <div class="game-grid">
                <a href="#" class="game-card" data-game="flappy-bird">
                    <i class="fas fa-feather-alt"></i> <h3>Evexa Buddy</h3>
                </a>
                <a href="#" class="game-card" data-game="city-runner">
                    <i class="fas fa-running"></i> <h3>City Runner</h3>
                </a>
                <a href="#" class="game-card" data-game="whack-a-mole">
                    <i class="fas fa-mouse"></i> <h3>Whack-a-Mole</h3>
                </a>
                <a href="#" class="game-card" data-game="space-pinball">
                    <i class="fas fa-space-shuttle"></i>
                    <h3>Space Pinball</h3>
                </a>
                <a href="#" class="game-card" data-game="dominoes">
                    <i class="fas fa-dice-five"></i>
                    <h3>Dominoes</h3>
                </a>
                <a href="#" class="game-card" data-game="hexaboard">
                    <i class="fas fa-chess-board"></i>
                    <h3>Hexaboard</h3>
                </a>
                <a href="#" class="game-card" data-game="rainbow-bead">
                    <i class="fas fa-gem"></i>
                    <h3>Rainbow Bead</h3>
                </a>
                <a href="#" class="game-card" data-game="goose-game">
                    <i class="fas fa-duck"></i>
                    <h3>Goose Game</h3>
                </a>
                <a href="#" class="game-card" data-game="marble-blast">
                    <i class="fas fa-circle"></i>
                    <h3>Marble Blast</h3>
                </a>
                <a href="#" class="game-card" data-game="four-colors">
                    <i class="fas fa-palette"></i>
                    <h3>Four Colors</h3>
                </a>
                <a href="#" class="game-card" data-game="mini-golf-world">
                    <i class="fas fa-golf-ball"></i>
                    <h3>Mini Golf World</h3>
                </a>
                <a href="#" class="game-card" data-game="going-nuts">
                    <i class="fas fa-squirrel"></i>
                    <h3>Going Nuts</h3>
                </a>
                <a href="#" class="game-card" data-game="darts">
                    <i class="fas fa-bullseye"></i>
                    <h3>Darts</h3>
                </a>
                <a href="#" class="game-card" data-game="nine-mens-morris">
                    <i class="fas fa-braille"></i>
                    <h3>Nine Men's Morris</h3>
                </a>
                <a href="#" class="game-card" data-game="space-miner">
                    <i class="fas fa-meteor"></i>
                    <h3>Space Miner</h3>
                </a>
                <a href="#" class="game-card" data-game="checkers">
                    <i class="fas fa-chess-pawn"></i>
                    <h3>Checkers</h3>
                </a>
                <a href="#" class="game-card" data-game="chess">
                    <i class="fas fa-chess-king"></i>
                    <h3>Chess</h3>
                </a>
                <a href="#" class="game-card" data-game="solitaire">
                    <i class="fas fa-hand-sparkles"></i>
                    <h3>Solitaire</h3>
                </a>
                <a href="#" class="game-card" data-game="quest">
                    <i class="fas fa-scroll"></i>
                    <h3>Quest</h3>
                </a>
                <a href="#" class="game-card" data-game="miniature-golf-game">
                    <i class="fas fa-flag-checkered"></i>
                    <h3>Miniature Golf Game</h3>
                </a>
                <a href="#" class="game-card" data-game="backgammon">
                    <i class="fas fa-dice"></i>
                    <h3>Backgammon</h3>
                </a>
                <a href="#" class="game-card" data-game="hercules">
                    <i class="fas fa-dumbbell"></i>
                    <h3>Hercules</h3>
                </a>
            </div>
            <div id="game-selection-ad" class="ad-placement glass-effect">
                <p>Google Ad Placeholder: Game Selection Page Ad (e.g., 336x280)</p>
            </div>
        </div>

        <div id="game-page" class="page-content">
            <div class="game-container glass-effect flappy-bird-game-elements">
                <canvas id="gameCanvas"></canvas>
                <div id="score-display">0</div>
                <div id="countdown-display"></div>
                <div id="level-up-display"></div>
                <div id="game-over-screen">
                    <h2>Game Over!</h2>
                    <p>Your Score: <span id="final-score">0</span></p>
                    <p>High Score: <span id="high-score">0</span></p>
                    <button id="restart-button" class="button button-primary">Restart Game</button>
                </div>
                <div id="game-start-overlay">
                    <p>Tap to Play</p>
                </div>
            </div>
            <div class="game-controls flappy-bird-game-elements">
                <button id="pause-resume-button" class="button button-primary"><i class="fas fa-pause"></i> Pause</button>
                <button id="stop-button" class="button button-primary"><i class="fas fa-stop"></i> Stop</button>
                <button id="rotate-button" class="button button-primary" style="display: none;"><i class="fas fa-mobile-alt"></i> Rotate</button>
            </div>
            <div id="game-ad" class="ad-placement glass-effect flappy-bird-game-elements">
                <p>Google Ad Placeholder: Game Page Ad (e.g., 300x250)</p>
                </div>

            <div id="dynamic-game-container"></div>
        </div>
    </div>

    <div class="bottom-navbar-container glass-effect" id="bottomNavbar">
        <a href="#" class="bottom-nav-item active" id="homeNavItem" data-page="smart-notepad-page">
            <div class="icon-background">
                <i class="fas fa-book"></i>
            </div>
            <span>Notepad</span>
        </a>
        <a href="#" class="bottom-nav-item" id="gameNavItem" data-page="game-selection-page">
            <div class="icon-background">
                <i class="fas fa-gamepad"></i>
            </div>
            <span>Game</span>
        </a>
        <a href="#" class="bottom-nav-item" id="appsNavItem">
            <div class="icon-background">
                <i class="fas fa-th-large"></i>
            </div>
            <span>Apps</span>
        </a>
        <a href="#" class="bottom-nav-item" id="profileNavItem">
            <div class="icon-background">
                <i class="fas fa-user"></i>
            </div>
            <span>Profile</span>
        </a>
    </div>

    <div id="rotation-hint">
        <i class="fas fa-mobile-alt"></i>
        <p>Rotate Device for Best Experience</p>
        <div class="button-group">
            <button id="play-portrait-button" class="button button-primary">Play Portrait</button>
            <button id="rotate-and-play-button" class="button button-primary">Rotate & Play</button>
        </div>
    </div>

    <script>
        // Global variables for game state and elements (Flappy Bird)
        let canvas, ctx, scoreDisplay, gameOverScreen, finalScoreDisplay, highScoreDisplay, restartButton;
        let countdownDisplay, levelUpDisplay, rotationHint;
        let birdX, birdY, birdVelocityY;
        let pipes = [];
        let score;
        let highScore = 0;
        let gameOver;
        let lastPipeSpawnTime = 0;
        let animationFrameId; // For Flappy Bird
        let gameStartTime;
        let currentPipeSpeed;
        let currentPipeSpawnInterval;
        let hasPlayedGameOverSound;
        let gameStarted = false; // Track if Flappy Bird has truly started (after countdown)
        let currentLevel = 1; // Flappy Bird: Current game level, starts at 1 (Very Easy)
        let gamePaused = false; // Flappy Bird: Track if game is paused

        // New: User preference for rotation. Default to true (suggest rotation)
        let userPrefersRotation = JSON.parse(localStorage.getItem('userPrefersRotation')) !== false; 
        let rotationHintDismissed = false; // Track if user skipped rotation hint for the current session

        // Game states enum
        const GAME_STATES = {
            GAME_START_OVERLAY: 'GAME_START_OVERLAY', // New initial state for game page
            COUNTDOWN: 'COUNTDOWN',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED', // New state
            GAME_OVER: 'GAME_OVER'
        };
        let currentGameState; // Will be set by initGame or showPage

        // Page elements
        let smartNotepadPage, gamePage, gameSelectionPage, gameStartOverlay;
        let dynamicGameContainer; // New: Reference to the dynamic game container

        // Game control buttons (Flappy Bird)
        let pauseResumeButton, stopButton, rotateButton;
        let flappyBirdGameElements; // New: Group of Flappy Bird specific elements

        // User profile elements
        let proBadge, toggleProButton;

        // Game constants (Flappy Bird)
        const BIRD_WIDTH = 40;
        const BIRD_HEIGHT = 30;
        const INITIAL_GRAVITY = 0.5;
        const INITIAL_JUMP_STRENGTH = -8;
        const PIPE_WIDTH = 60;
        const PIPE_GAP = 150;
        const GROUND_HEIGHT = 80;

        // Desired internal canvas resolution for game logic (landscape)
        const GAME_CANVAS_WIDTH = 550;
        const GAME_CANVAS_HEIGHT = 450;

        // Difficulty levels (speed and spawn interval) with background themes (Flappy Bird)
        const DIFFICULTY_LEVELS = {
            1: { speed: 2, interval: 1500, scoreThreshold: 5, name: "Very Easy", skyColor: '#70c5ce', groundColor: '#d2b48c', backgroundType: 'default' },
            2: { speed: 2.5, interval: 1300, scoreThreshold: 10, name: "Easy", skyColor: '#87CEEB', groundColor: '#deb887', backgroundType: 'clouds' },
            3: { speed: 3, interval: 1100, scoreThreshold: 20, name: "Medium", skyColor: '#4A90E2', groundColor: '#7a5230', backgroundType: 'mountains' },
            4: { speed: 3.5, interval: 900, scoreThreshold: 35, name: "Hard", skyColor: '#36454F', groundColor: '#5a3a2b', backgroundType: 'night' },
            5: { speed: 4, interval: 700, scoreThreshold: 50, name: "Very Hard", skyColor: '#2C3E50', groundColor: '#4a2a1c', backgroundType: 'stormy' }
        };

        // Bird colors (fixed, not changing per level as per user request)
        const BIRD_COLORS = {
            body: '#FFD700', /* Gold yellow */
            beak: '#FFA500', /* Orange */
            eye: 'black',
            wing: 'rgba(255, 255, 255, 0.7)'
        };

        // Sound effects and music using Tone.js
        let jumpSynth = null; // Flappy Bird
        let gameOverSynth = null; // Flappy Bird
        let backgroundMusicLoop = null; // Flappy Bird
        let backgroundMusicSynth = null; // Flappy Bird

        // Whack-a-Mole specific audio
        let whackAMoleBackgroundMusicLoop = null;
        let whackAMoleBackgroundMusicSynth = null;
        let molePopSound = null;
        let moleWhackSound = null;
        let whackAMoleGameOverSound = null;
        let whackAMoleBombSound = null; // New sound for bomb mole

        // Space Miner specific audio
        let spaceMinerBackgroundMusicLoop = null;
        let spaceMinerBackgroundMusicSynth = null;
        let shootSound = null;
        let explosionSound = null;

        // City Runner specific audio
        let cityRunnerBackgroundMusicLoop = null;
        let cityRunnerBackgroundMusicSynth = null;
        let cityRunnerJumpSound = null;
        let cityRunnerCollisionSound = null;


        // Flag to ensure audio context and synths are ready
        let isAudioReady = false;

        // Function to set canvas dimensions dynamically (Flappy Bird)
        function setCanvasDimensions() {
            // Always set canvas internal resolution to the desired landscape size
            canvas.width = GAME_CANVAS_WIDTH;
            canvas.height = GAME_CANVAS_HEIGHT;
            // CSS will handle visual scaling and rotation of the game-container and canvas
        }

        // Draw bird (stylized using Canvas API) - now uses fixed colors
        function drawBird() {
            // Bird body (oval)
            ctx.fillStyle = BIRD_COLORS.body;
            ctx.beginPath();
            ctx.ellipse(birdX + BIRD_WIDTH / 2, birdY + BIRD_HEIGHT / 2, BIRD_WIDTH / 2, BIRD_HEIGHT / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520'; /* Goldenrod */
            ctx.lineWidth = 2;
            ctx.stroke();

            // Beak (triangle)
            ctx.fillStyle = BIRD_COLORS.beak;
            ctx.beginPath();
            ctx.moveTo(birdX + BIRD_WIDTH - 5, birdY + BIRD_HEIGHT / 2);
            ctx.lineTo(birdX + BIRD_WIDTH + 10, birdY + BIRD_HEIGHT / 2 - 5);
            ctx.lineTo(birdX + BIRD_WIDTH + 10, birdY + BIRD_HEIGHT / 2 + 5);
            ctx.closePath();
            ctx.fill();

            // Eye (black circle with white highlight)
            ctx.fillStyle = BIRD_COLORS.eye;
            ctx.beginPath();
            ctx.arc(birdX + BIRD_WIDTH / 2 + 8, birdY + BIRD_HEIGHT / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(birdX + BIRD_WIDTH / 2 + 9, birdY + BIRD_HEIGHT / 2 - 6, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Simple wing (animated, slight rotation)
            ctx.save();
            ctx.translate(birdX + BIRD_WIDTH / 2, birdY + BIRD_HEIGHT / 2);
            let wingRotation = Math.sin(Date.now() * 0.01) * 0.2;
            ctx.rotate(wingRotation);

            ctx.fillStyle = BIRD_COLORS.wing;
            ctx.beginPath();
            ctx.ellipse(0, 5, BIRD_WIDTH / 3, BIRD_HEIGHT / 3, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Draw pipes
        function drawPipes() {
            pipes.forEach(pipe => {
                // Top pipe
                ctx.fillStyle = '#228B22';
                ctx.strokeStyle = '#006400';
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.rect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
                ctx.fill();
                ctx.stroke();

                // Top pipe cap
                ctx.fillStyle = '#3CB371';
                ctx.beginPath();
                ctx.rect(pipe.x - 5, pipe.topHeight - 20, PIPE_WIDTH + 10, 20);
                ctx.fill();
                ctx.stroke();

                // Bottom pipe
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.rect(pipe.x, pipe.bottomY, PIPE_WIDTH, canvas.height - pipe.bottomY - GROUND_HEIGHT);
                ctx.fill();
                ctx.stroke();

                // Bottom pipe cap
                ctx.fillStyle = '#3CB371';
                ctx.beginPath();
                ctx.rect(pipe.x - 5, pipe.bottomY, PIPE_WIDTH + 10, 20);
                ctx.fill();
                ctx.stroke();
            });
        }

        // Draw dynamic background elements based on level
        function drawBackgroundElements(level) {
            const backgroundType = DIFFICULTY_LEVELS[level].backgroundType;

            if (backgroundType === 'clouds' || backgroundType === 'default') {
                // Draw simple clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(canvas.width * 0.2, canvas.height * 0.2, 30, 0, Math.PI * 2);
                ctx.arc(canvas.width * 0.25, canvas.height * 0.2 + 10, 25, 0, Math.PI * 2);
                ctx.arc(canvas.width * 0.3, canvas.height * 0.2, 30, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(canvas.width * 0.7, canvas.height * 0.15, 40, 0, Math.PI * 2);
                ctx.arc(canvas.width * 0.75, canvas.height * 0.15 + 15, 35, 0, Math.PI * 2);
                ctx.arc(canvas.width * 0.8, canvas.height * 0.15, 40, 0, Math.PI * 2);
                ctx.fill();
            } else if (backgroundType === 'mountains' || backgroundType === 'night' || backgroundType === 'stormy') {
                // Draw simple mountains
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; /* Darker overlay for mountains */
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
                ctx.lineTo(canvas.width * 0.3, canvas.height - GROUND_HEIGHT - 80);
                ctx.lineTo(canvas.width * 0.6, canvas.height - GROUND_HEIGHT - 40);
                ctx.lineTo(canvas.width * 0.8, canvas.height - GROUND_HEIGHT - 100);
                ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; /* Lighter overlay for mountains */
                ctx.beginPath();
                ctx.moveTo(canvas.width * 0.1, canvas.height - GROUND_HEIGHT);
                ctx.lineTo(canvas.width * 0.4, canvas.height - GROUND_HEIGHT - 60);
                ctx.lineTo(canvas.width * 0.7, canvas.height - GROUND_HEIGHT - 20);
                ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw ground (Flappy Bird)
        function drawGround() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground-brown');
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, canvas.height - GROUND_HEIGHT);
                ctx.lineTo(i + 10, canvas.height - GROUND_HEIGHT + 10);
                ctx.stroke();
            }
        }

        // Update game state (Flappy Bird)
        function update() {
            if (currentGameState !== GAME_STATES.PLAYING) return;

            birdVelocityY += INITIAL_GRAVITY;
            birdY += birdVelocityY;

            if (birdY + BIRD_HEIGHT > canvas.height - GROUND_HEIGHT) {
                birdY = canvas.height - BIRD_HEIGHT - GROUND_HEIGHT;
                currentGameState = GAME_STATES.GAME_OVER;
            }
            if (birdY < 0) {
                birdY = 0;
                birdVelocityY = 0;
            }

            // Check for level up
            const nextLevelData = DIFFICULTY_LEVELS[currentLevel + 1];
            if (nextLevelData && score >= DIFFICULTY_LEVELS[currentLevel].scoreThreshold) {
                currentLevel++;
                applyLevelDifficulty();
                showLevelUpMessage(currentLevel);
            }

            const currentTime = Date.now();
            if (currentTime - lastPipeSpawnTime > currentPipeSpawnInterval) {
                const minHeight = 50;
                const maxHeight = canvas.height - PIPE_GAP - minHeight - GROUND_HEIGHT;
                const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
                const bottomY = topHeight + PIPE_GAP;
                pipes.push({ x: canvas.width, topHeight: topHeight, bottomY: bottomY, passed: false });
                lastPipeSpawnTime = currentTime;
            }

            pipes.forEach(pipe => {
                pipe.x -= currentPipeSpeed;

                // Collision detection: Check if bird overlaps with pipe horizontally and vertically
                if (
                    birdX < pipe.x + PIPE_WIDTH && // Bird's left edge is to the left of pipe's right edge
                    birdX + BIRD_HEIGHT > pipe.x && // Bird's right edge is to the right of pipe's left edge (FIXED BUG HERE)
                    (birdY < pipe.topHeight || birdY + BIRD_HEIGHT > pipe.bottomY) // Bird's top or bottom edge overlaps with pipe's top/bottom opening
                ) {
                    currentGameState = GAME_STATES.GAME_OVER;
                }

                if (pipe.x + PIPE_WIDTH < birdX && !pipe.passed) {
                    score++;
                    scoreDisplay.textContent = score;
                    pipe.passed = true;

                    scoreDisplay.classList.add('score-pop');
                    setTimeout(() => {
                        scoreDisplay.classList.remove('score-pop');
                    }, 150);

                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('flappyBirdHighScore', highScore);
                        highScoreDisplay.textContent = highScore;
                    }
                }
            });

            pipes = pipes.filter(pipe => pipe.x + PIPE_WIDTH > 0);

            if (currentGameState === GAME_STATES.GAME_OVER) {
                finalScoreDisplay.textContent = score;
                gameOverScreen.classList.add('active');
                if (isAudioReady && gameOverSynth && Tone.context.state === 'running' && !hasPlayedGameOverSound) {
                    gameOverSynth.triggerAttackRelease("8n");
                    hasPlayedGameOverSound = true;
                }
                if (backgroundMusicLoop && backgroundMusicLoop.state === 'started') {
                    backgroundMusicLoop.stop();
                }
                cancelAnimationFrame(animationFrameId);
            }
        }

        // Game loop (Flappy Bird)
        function gameLoop() {
            if (currentGameState === GAME_STATES.PAUSED) {
                animationFrameId = requestAnimationFrame(gameLoop); // Keep requesting frame even if paused
                return; // Don't update game state if paused
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Update background colors based on current level
            document.documentElement.style.setProperty('--sky-blue', DIFFICULTY_LEVELS[currentLevel].skyColor);
            document.documentElement.style.setProperty('--ground-brown', DIFFICULTY_LEVELS[currentLevel].groundColor);

            drawBackgroundElements(currentLevel); // Draw level-specific background elements
            drawPipes();
            drawGround();
            drawBird();
            update();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Bird jump function
        function jump() {
            if (currentGameState === GAME_STATES.PLAYING) {
                birdVelocityY = INITIAL_JUMP_STRENGTH;
                if (isAudioReady && jumpSynth && Tone.context.state === 'running') {
                    jumpSynth.triggerAttackRelease("C4", "8n");
                }
            } else if (currentGameState === GAME_STATES.GAME_START_OVERLAY) {
                // If on mobile portrait and user prefers rotation, show hint
                const isMobile = window.innerWidth < 769;
                const isPortrait = window.innerHeight > window.innerWidth;

                if (isMobile && isPortrait && userPrefersRotation && !rotationHintDismissed) {
                    rotationHint.classList.add('active');
                } else {
                    // Otherwise, proceed directly to countdown
                    gameStartOverlay.classList.add('hidden'); // Hide "Tap to Play"
                    startCountdown();
                }
            }
        }

        // Pause Game (Flappy Bird)
        function pauseGame() {
            if (currentGameState === GAME_STATES.PLAYING) {
                currentGameState = GAME_STATES.PAUSED;
                pauseResumeButton.innerHTML = '<i class="fas fa-play"></i> Resume';
                if (backgroundMusicLoop && backgroundMusicLoop.state === 'started') {
                    backgroundMusicLoop.pause();
                }
            }
        }

        // Resume Game (Flappy Bird)
        function resumeGame() {
            if (currentGameState === GAME_STATES.PAUSED) {
                currentGameState = GAME_STATES.PLAYING;
                pauseResumeButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
                if (backgroundMusicLoop && backgroundMusicLoop.state === 'paused') {
                    backgroundMusicLoop.start();
                }
                gameLoop(); // Restart the animation loop
            }
        }

        // Toggle Pause/Resume (Flappy Bird)
        function togglePauseResume() {
            if (currentGameState === GAME_STATES.PLAYING) {
                pauseGame();
            } else if (currentGameState === GAME_STATES.PAUSED) {
                resumeGame();
            }
        }

        // Stop Game (Flappy Bird)
        function stopGame() {
            if (currentGameState !== GAME_STATES.GAME_OVER) { // Prevent stopping if already over
                currentGameState = GAME_STATES.GAME_OVER;
                finalScoreDisplay.textContent = score;
                gameOverScreen.classList.add('active');
                if (backgroundMusicLoop && backgroundMusicLoop.state === 'started') {
                    backgroundMusicLoop.stop();
                }
                cancelAnimationFrame(animationFrameId);
                // Reset pause/resume button state
                pauseResumeButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
                gamePaused = false;
            }
        }

        // Toggle Rotation (for mobile portrait)
        function toggleRotation() {
            userPrefersRotation = !userPrefersRotation;
            localStorage.setItem('userPrefersRotation', userPrefersRotation);
            checkOrientation(); // Apply new rotation preference
            // Update button text
            if (userPrefersRotation) {
                rotateButton.innerHTML = '<i class="fas fa-mobile-alt"></i> Play Portrait';
            } else {
                rotateButton.innerHTML = '<i class="fas fa-mobile-alt"></i> Rotate';
            }
        }


        // Apply difficulty settings based on current level (Flappy Bird)
        function applyLevelDifficulty() {
            const levelData = DIFFICULTY_LEVELS[currentLevel];
            if (levelData) {
                currentPipeSpeed = levelData.speed;
                currentPipeSpawnInterval = levelData.interval;
                console.log(`Level ${currentLevel}: Speed ${currentPipeSpeed}, Interval ${currentPipeSpawnInterval}`);
            } else {
                // If no specific level data, use the last defined level's settings
                const lastLevel = Object.keys(DIFFICULTY_LEVELS).pop();
                const lastLevelData = DIFFICULTY_LEVELS[lastLevel];
                currentPipeSpeed = lastLevelData.speed;
                currentPipeSpawnInterval = lastLevelData.interval;
                console.log(`Max Level Reached (${lastLevel}): Speed ${currentPipeSpeed}, Interval ${currentPipeSpawnInterval}`);
            }
        }

        // Show level up message (Flappy Bird)
        function showLevelUpMessage(level) {
            levelUpDisplay.textContent = `Level ${level}!`;
            levelUpDisplay.classList.add('active');
            setTimeout(() => {
                levelUpDisplay.classList.remove('active');
            }, 2000); // Display for 2 seconds
        }

        // Countdown before game starts (Flappy Bird)
        function startCountdown() {
            currentGameState = GAME_STATES.COUNTDOWN;
            let count = 3;
            countdownDisplay.classList.add('active');
            const countdownInterval = setInterval(() => {
                if (count > 0) {
                    countdownDisplay.textContent = count;
                } else {
                    countdownDisplay.textContent = 'Go!';
                    clearInterval(countdownInterval);
                    setTimeout(() => {
                        countdownDisplay.classList.remove('active');
                        currentGameState = GAME_STATES.PLAYING; // Allow game to start after countdown
                        gameStartTime = Date.now(); // Start game timer
                        gameLoop(); // Start the game loop
                        if (backgroundMusicLoop && backgroundMusicLoop.state !== 'started') {
                            backgroundMusicLoop.start();
                        }
                    }, 500); // "Go!" stays for 0.5s
                }
                count--; // Decrement after displaying
            }, 1000); // Update every 1 second
        }

        // Initialize game (Flappy Bird)
        async function initGame() {
            await startAudioContext(); // Ensure audio context is ready and synths are initialized
            setCanvasDimensions();
            birdX = 50;
            birdY = canvas.height / 2 - BIRD_HEIGHT / 2;
            birdVelocityY = 0;
            pipes = [];
            score = 0;
            gameOver = false;
            hasPlayedGameOverSound = false;
            lastPipeSpawnTime = 0;
            currentLevel = 1; // Always start at level 1 (Very Easy)
            applyLevelDifficulty(); // Apply initial difficulty

            // Ensure game elements are visible and overlay is shown
            // The display property for flappyBirdGameElements is handled by CSS class 'flappy-bird-active'
            // when gameId === 'flappy-bird'.
            
            canvas.style.display = 'block';
            scoreDisplay.style.display = 'block';
            gameOverScreen.classList.remove('active'); // Hide game over screen
            gameStartOverlay.classList.remove('hidden'); // Show "Tap to Play" overlay
            
            currentGameState = GAME_STATES.GAME_START_OVERLAY; // Set initial state for game page
            gamePaused = false; // Reset pause state
            pauseResumeButton.innerHTML = '<i class="fas fa-pause"></i> Pause'; // Reset button text

            scoreDisplay.textContent = score;
            highScore = parseInt(localStorage.getItem('flappyBirdHighScore') || '0');
            highScoreDisplay.textContent = highScore;

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            // Do not start countdown here, it will be triggered by user interaction on overlay
        }

        // --------------------------------------------------------------------
        // Common Functions
        // --------------------------------------------------------------------

        // Stop all game-specific music loops
        function stopAllGameMusic() {
            if (backgroundMusicLoop && backgroundMusicLoop.state === 'started') {
                backgroundMusicLoop.stop();
            }
            if (whackAMoleBackgroundMusicLoop && whackAMoleBackgroundMusicLoop.state === 'started') {
                whackAMoleBackgroundMusicLoop.stop();
            }
            if (spaceMinerBackgroundMusicLoop && spaceMinerBackgroundMusicLoop.state === 'started') {
                spaceMinerBackgroundMusicLoop.stop();
            }
            if (cityRunnerBackgroundMusicLoop && cityRunnerBackgroundMusicLoop.state === 'started') {
                cityRunnerBackgroundMusicLoop.stop();
            }
        }

        // Start Tone.js audio context on user interaction
        const startAudioContext = async () => {
            if (isAudioReady) return true; // Already ready

            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("Tone.js audio context started.");
                } catch (e) {
                    console.error("Tone.js context failed to start:", e);
                    return false; // Indicate failure
                }
            }
            
            // Initialize synths if they are not already initialized
            if (!jumpSynth) { 
                jumpSynth = new Tone.Synth().toDestination();
                gameOverSynth = new Tone.NoiseSynth().toDestination();
                backgroundMusicSynth = new Tone.Synth().toDestination();
                backgroundMusicLoop = new Tone.Loop(time => {
                    backgroundMusicSynth.triggerAttackRelease("C3", "4n", time);
                    backgroundMusicSynth.triggerAttackRelease("E3", "4n", time + 0.5);
                    backgroundMusicSynth.triggerAttackRelease("G3", "4n", time + 1);
                    backgroundMusicSynth.triggerAttackRelease("C4", "4n", time + 1.5);
                }, "2n");
            }

            // Initialize Whack-a-Mole synths
            if (!whackAMoleBackgroundMusicSynth) {
                whackAMoleBackgroundMusicSynth = new Tone.Synth().toDestination();
                whackAMoleBackgroundMusicLoop = new Tone.Loop(time => {
                    whackAMoleBackgroundMusicSynth.triggerAttackRelease("C3", "8n", time);
                    whackAMoleBackgroundMusicSynth.triggerAttackRelease("G3", "8n", time + 0.5);
                }, "1n"); // Play every 1 second
                molePopSound = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }
                }).toDestination();
                moleWhackSound = new Tone.MembraneSynth().toDestination();
                whackAMoleGameOverSound = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
                }).toDestination();
                whackAMoleBombSound = new Tone.NoiseSynth({ // New: Bomb sound
                    noise: { type: "white" },
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 }
                }).toDestination();
            }

            // Initialize Space Miner synths
            if (!spaceMinerBackgroundMusicSynth) {
                spaceMinerBackgroundMusicSynth = new Tone.Synth().toDestination();
                spaceMinerBackgroundMusicLoop = new Tone.Loop(time => {
                    spaceMinerBackgroundMusicSynth.triggerAttackRelease("C3", "8n", time);
                    spaceMinerBackgroundMusicSynth.triggerAttackRelease("G3", "8n", time + 0.5);
                    spaceMinerBackgroundMusicSynth.triggerAttackRelease("C4", "8n", time + 1);
                }, "1n");
                shootSound = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.05 }
                }).toDestination();
                explosionSound = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
            }

            // Initialize City Runner synths
            if (!cityRunnerBackgroundMusicSynth) {
                cityRunnerBackgroundMusicSynth = new Tone.Synth().toDestination();
                cityRunnerBackgroundMusicLoop = new Tone.Loop(time => {
                    cityRunnerBackgroundMusicSynth.triggerAttackRelease("C4", "8n", time);
                    cityRunnerBackgroundMusicSynth.triggerAttackRelease("E4", "8n", time + 0.25);
                    cityRunnerBackgroundMusicSynth.triggerAttackRelease("G4", "8n", time + 0.5);
                }, "1n"); // Play every 1 second
                cityRunnerJumpSound = new Tone.Synth().toDestination();
                cityRunnerCollisionSound = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0 }
                }).toDestination();
            }

            isAudioReady = true; // Set flag to true after successful initialization
            return true; // Indicate success
        };

        // Function to show/hide pages
        async function showPage(pageId) {
            const pages = document.querySelectorAll('.page-content');
            pages.forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');

            // Update active state in sidebar and bottom navbar
            const navLinks = document.querySelectorAll('.sidebar nav ul li a, .bottom-navbar-container .bottom-nav-item');
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Stop all game loops and music when changing pages
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (animationFrameIdSpaceMiner) { // Stop Space Miner animation loop
                cancelAnimationFrame(animationFrameIdSpaceMiner);
                animationFrameIdSpaceMiner = null;
            }
            if (animationFrameIdCityRunner) { // Stop City Runner animation loop
                cancelAnimationFrame(animationFrameIdCityRunner);
                animationFrameIdCityRunner = null;
            }
            stopAllGameMusic(); // Stop all background music

            // Clear dynamic game container and hide Flappy Bird elements when not on game-page
            if (pageId !== 'game-page') {
                dynamicGameContainer.innerHTML = ''; // Clear any loaded game
                flappyBirdGameElements.forEach(el => el.style.display = 'none'); // Hide Flappy Bird elements
                gamePage.classList.remove('flappy-bird-active'); // Remove class to hide Flappy Bird elements
            }

            // Initialize specific game if navigating to its page
            if (pageId === 'game-page') { 
                // Initialization for Flappy Bird happens when its card is clicked.
                // If navigating directly to game-page, it will just show the last loaded game or empty.
            } else {
                // Ensure rotation hint is hidden when not on game page
                rotationHint.classList.remove('active');
                // Hide rotate button if not on game page
                if (rotateButton) {
                    rotateButton.style.display = 'none';
                }
            }
            checkOrientation(); // Re-evaluate orientation on page change
        }

        // Check device orientation and apply game box rotation
        function checkOrientation() {
            const isMobile = window.innerWidth < 769;
            const isPortrait = window.innerHeight > window.innerWidth;
            const flappyBirdGameContainer = document.querySelector('#game-page .game-container');
            const isOnFlappyBirdPage = gamePage.classList.contains('active') && gamePage.classList.contains('flappy-bird-active');

            // Handle Flappy Bird rotation
            if (isMobile && isOnFlappyBirdPage) {
                if (rotateButton) {
                    rotateButton.style.display = 'inline-block';
                    if (userPrefersRotation) {
                        rotateButton.innerHTML = '<i class="fas fa-mobile-alt"></i> Play Portrait';
                    } else {
                        rotateButton.innerHTML = '<i class="fas fa-mobile-alt"></i> Rotate';
                    }
                }

                if (isPortrait) {
                    if (userPrefersRotation) {
                        flappyBirdGameContainer.classList.remove('no-rotate');
                        flappyBirdGameContainer.classList.add('rotated');
                    } else {
                        flappyBirdGameContainer.classList.remove('rotated');
                        flappyBirdGameContainer.classList.add('no-rotate');
                    }
                } else {
                    rotationHint.classList.remove('active');
                    flappyBirdGameContainer.classList.remove('rotated');
                    flappyBirdGameContainer.classList.remove('no-rotate');
                }
            } else {
                rotationHint.classList.remove('active');
                if (flappyBirdGameContainer) {
                    flappyBirdGameContainer.classList.remove('rotated');
                    flappyBirdGameContainer.classList.remove('no-rotate');
                }
                if (rotateButton) {
                    rotateButton.style.display = 'none';
                }
            }
            
            // Re-set canvas internal dimensions for Flappy Bird
            if (canvas) setCanvasDimensions();
        }

        // Function to toggle Pro status
        function toggleProStatus() {
            isProUser = !isProUser;
            if (isProUser) {
                proBadge.classList.add('active');
                toggleProButton.textContent = 'Downgrade to Free';
            } else {
                proBadge.classList.remove('active');
                toggleProButton.textContent = 'Upgrade to Pro';
            }
            localStorage.setItem('isProUser', isProUser); // Save preference
        }

        // Whack-a-Mole Game Logic
        let moles = [];
        let whackAMoleScore = 0;
        let whackAMoleTimeLeft = 30; // seconds
        let whackAMoleGameActive = false;
        let molePopInterval;
        let timerInterval;
        let whackAMoleScoreDisplay, whackAMoleTimerDisplay, whackAMoleGameOverScreen, whackAMoleFinalScoreDisplay, whackAMoleHighScoreDisplay, whackAMoleStartButton, whackAMoleResetButton, whackAMoleBackToGamesButton;
        let whackAMoleHighScore = 0; // New variable for Whack-a-Mole high score
        let whackAMoleLevel = 1; // New: Whack-a-Mole difficulty level

        // New: Mole type definitions for Whack-a-Mole
        const MOLE_TYPES = {
            NORMAL: {
                content: '', // Hedgehog
                points: 10,
                baseMinDuration: 800,
                baseMaxDuration: 1500,
                spawnChance: 0.7, // 70% chance
                sound: 'moleWhackSound'
            },
            FAST: {
                content: '', // Lightning bolt
                points: 25,
                baseMinDuration: 400,
                baseMaxDuration: 800,
                spawnChance: 0.2, // 20% chance
                sound: 'moleWhackSound'
            },
            BOMB: {
                content: '', // Bomb
                points: -50,
                baseMinDuration: 1000,
                baseMaxDuration: 2000,
                spawnChance: 0.1, // 10% chance
                sound: 'whackAMoleBombSound'
            }
        };

        // New: Difficulty levels for Whack-a-Mole
        const WHACK_A_MOLE_DIFFICULTY = {
            1: { name: "Easy", scoreThreshold: 50, speedMultiplier: 1, bombChanceIncrease: 0 },
            2: { name: "Medium", scoreThreshold: 150, speedMultiplier: 0.9, bombChanceIncrease: 0.02 },
            3: { name: "Hard", scoreThreshold: 300, speedMultiplier: 0.8, bombChanceIncrease: 0.05 },
            4: { name: "Very Hard", scoreThreshold: 500, speedMultiplier: 0.7, bombChanceIncrease: 0.08 },
            5: { name: "Insane", scoreThreshold: 9999, speedMultiplier: 0.6, bombChanceIncrease: 0.1 }
        };

        function initializeWhackAMoleGame() {
            stopAllGameMusic();
            if (isAudioReady && whackAMoleBackgroundMusicLoop && whackAMoleBackgroundMusicLoop.state !== 'started') {
                whackAMoleBackgroundMusicLoop.start();
            }

            const whackAMoleHtmlFragment = `
                <div class="game-container whack-a-mole-game">
                    <h1>Whack-a-Mole</h1>
                    <div class="game-stats">
                        <div>Score: <span id="whack-a-mole-score">0</span></div>
                        <div>Time: <span id="whack-a-mole-timer">30s</span></div>
                    </div>
                    <div class="mole-grid" id="mole-grid">
                        <div class="hole"><div class="mole" data-index="0"></div></div>
                        <div class="hole"><div class="mole" data-index="1"></div></div>
                        <div class="hole"><div class="mole" data-index="2"></div></div>
                        <div class="hole"><div class="mole" data-index="3"></div></div>
                        <div class="hole"><div class="mole" data-index="4"></div></div>
                        <div class="hole"><div class="mole" data-index="5"></div></div>
                        <div class="hole"><div class="mole" data-index="6"></div></div>
                        <div class="hole"><div class="mole" data-index="7"></div></div>
                        <div class="hole"><div class="mole" data-index="8"></div></div>
                    </div>
                    <div class="whack-a-mole-controls">
                        <button id="whack-a-mole-start-button" class="button button-primary">Start Game</button>
                        <button id="whack-a-mole-reset-button" class="button button-primary">Reset</button>
                    </div>
                    <button id="whack-a-mole-back-to-games-button" class="button button-primary" style="margin-top: 20px;">Back to Games</button>

                    <div class="ad-placement glass-effect" style="margin-top: 20px;">
                        <p>Google Ad Placeholder: Whack-a-Mole Ad (e.g., 300x250)</p>
                    </div>

                    <div class="whack-a-mole-game-over" id="whack-a-mole-game-over">
                        <h2>Time's Up!</h2>
                        <p>Final Score: <span id="whack-a-mole-final-score">0</span></p>
                        <p>High Score: <span id="whack-a-mole-high-score-display">0</span></p> <button id="whack-a-mole-restart-button" class="button button-primary">Play Again</button>
                    </div>
                </div>
            `;
            dynamicGameContainer.innerHTML = whackAMoleHtmlFragment;

            whackAMoleScoreDisplay = dynamicGameContainer.querySelector('#whack-a-mole-score');
            whackAMoleTimerDisplay = dynamicGameContainer.querySelector('#whack-a-mole-timer');
            whackAMoleGameOverScreen = dynamicGameContainer.querySelector('#whack-a-mole-game-over');
            whackAMoleFinalScoreDisplay = dynamicGameContainer.querySelector('#whack-a-mole-final-score');
            whackAMoleHighScoreDisplay = dynamicGameContainer.querySelector('#whack-a-mole-high-score-display'); // Get the new element
            whackAMoleStartButton = dynamicGameContainer.querySelector('#whack-a-mole-start-button');
            whackAMoleResetButton = dynamicGameContainer.querySelector('#whack-a-mole-reset-button');
            whackAMoleBackToGamesButton = dynamicGameContainer.querySelector('#whack-a-mole-back-to-games-button');
            moles = dynamicGameContainer.querySelectorAll('.mole');

            moles.forEach(mole => {
                mole.addEventListener('click', whackMole);
            });

            whackAMoleStartButton.addEventListener('click', startGame);
            whackAMoleResetButton.addEventListener('click', resetWhackAMoleGame);
            whackAMoleGameOverScreen.querySelector('#whack-a-mole-restart-button').addEventListener('click', resetWhackAMoleGame);
            whackAMoleBackToGamesButton.addEventListener('click', () => {
                stopAllGameMusic(); // Stop Whack-a-Mole music
                if (typeof showPage === 'function') {
                    showPage('game-selection-page');
                } else {
                    console.warn("showPage function not found. Cannot navigate back to game selection.");
                    dynamicGameContainer.innerHTML = '';
                }
            });

            // Load high score on initialization
            whackAMoleHighScore = parseInt(localStorage.getItem('whackAMoleHighScore') || '0');
            whackAMoleHighScoreDisplay.textContent = whackAMoleHighScore;

            resetWhackAMoleGame(); // Initial state setup
        }

        // Helper to show score feedback
        function showScoreFeedback(moleElement, scoreChange) {
            const feedback = document.createElement('div');
            feedback.textContent = (scoreChange > 0 ? '+' : '') + scoreChange;
            feedback.classList.add('score-feedback');
            if (scoreChange < 0) {
                feedback.classList.add('negative');
            }

            // Position the feedback above the mole
            const moleRect = moleElement.getBoundingClientRect();
            const gridRect = moleElement.closest('.mole-grid').getBoundingClientRect();

            feedback.style.left = `${moleRect.left - gridRect.left + moleRect.width / 2}px`;
            feedback.style.top = `${moleRect.top - gridRect.top + moleRect.height / 2}px`;
            feedback.style.transform = 'translateX(-50%) translateY(0)'; // Initial position

            moleElement.closest('.hole').appendChild(feedback);

            feedback.addEventListener('animationend', () => {
                feedback.remove();
            });
        }


        function randomTime(min, max) {
            // Apply difficulty multiplier
            const multiplier = WHACK_A_MOLE_DIFFICULTY[whackAMoleLevel].speedMultiplier;
            return Math.round(Math.random() * (max - min) + min) * multiplier;
        }

        function randomMole(molesArray) {
            const upMoles = Array.from(molesArray).filter(m => m.classList.contains('up'));
            let availableMoles = Array.from(molesArray).filter(m => !m.classList.contains('up'));

            if (availableMoles.length === 0) {
                // If all moles are up, pick one that's already up to re-pop or just return null
                if (upMoles.length > 0) {
                    return upMoles[Math.floor(Math.random() * upMoles.length)];
                }
                return null; // No moles available
            }

            const idx = Math.floor(Math.random() * availableMoles.length);
            return availableMoles[idx];
        }

        function popRandomMole() {
            if (!whackAMoleGameActive) return;

            const moleElement = randomMole(moles);
            if (!moleElement) {
                // If no available moles, try again shortly
                setTimeout(popRandomMole, 200);
                return;
            }

            // Determine mole type based on spawn chances and current difficulty
            let moleTypeKey = 'NORMAL';
            const rand = Math.random();
            const currentBombChance = MOLE_TYPES.BOMB.spawnChance + WHACK_A_MOLE_DIFFICULTY[whackAMoleLevel].bombChanceIncrease;

            if (rand < currentBombChance) {
                moleTypeKey = 'BOMB';
            } else if (rand < currentBombChance + MOLE_TYPES.FAST.spawnChance) {
                moleTypeKey = 'FAST';
            }
            // If none of the above, it defaults to NORMAL (due to spawnChance sum being 1)

            const moleType = MOLE_TYPES[moleTypeKey];

            moleElement.textContent = moleType.content; // Set emoji/content
            moleElement.dataset.type = moleTypeKey; // Store type in data attribute
            moleElement.style.backgroundColor = moleType.color; // Set initial color

            moleElement.classList.add('up');
            if (isAudioReady && molePopSound && Tone.context.state === 'running') {
                molePopSound.triggerAttackRelease("C5", "16n");
            }

            const duration = randomTime(moleType.baseMinDuration, moleType.baseMaxDuration);
            moleElement.moleTimeout = setTimeout(() => { // Store timeout ID on the mole element
                moleElement.classList.remove('up');
                moleElement.classList.remove('hit'); // Ensure hit class is removed
                if (whackAMoleGameActive) {
                    popRandomMole(); // Keep moles popping if game is active
                }
            }, duration);
        }

        function whackMole(e) {
            const moleElement = e.target;
            if (!whackAMoleGameActive || !moleElement.classList.contains('up')) return;

            clearTimeout(moleElement.moleTimeout); // Clear the mole's auto-hide timeout

            const moleTypeKey = moleElement.dataset.type;
            const moleType = MOLE_TYPES[moleTypeKey];

            whackAMoleScore += moleType.points;
            whackAMoleScoreDisplay.textContent = whackAMoleScore;
            
            showScoreFeedback(moleElement, moleType.points); // Show score pop-up

            moleElement.classList.remove('up'); // Hide mole immediately
            moleElement.classList.add('hit'); // Add hit animation
            moleElement.style.backgroundColor = moleType.color; // Change color on hit

            if (isAudioReady && Tone.context.state === 'running') {
                if (moleType.sound === 'whackAMoleBombSound' && whackAMoleBombSound) {
                    whackAMoleBombSound.triggerAttackRelease("8n");
                } else if (moleType.sound === 'moleWhackSound' && moleWhackSound) {
                    moleWhackSound.triggerAttackRelease("C2", "8n");
                }
            }

            setTimeout(() => {
                moleElement.classList.remove('hit'); // Remove hit class after animation
                moleElement.style.backgroundColor = moleType.color; // Reset color
                if (whackAMoleGameActive) {
                    popRandomMole(); // Pop a new mole
                }
            }, 100); // Short delay for hit animation

            updateWhackAMoleDifficulty(); // Check for difficulty update
        }

        function updateWhackAMoleDifficulty() {
            const nextLevel = whackAMoleLevel + 1;
            if (WHACK_A_MOLE_DIFFICULTY[nextLevel] && whackAMoleScore >= WHACK_A_MOLE_DIFFICULTY[whackAMoleLevel].scoreThreshold) {
                whackAMoleLevel = nextLevel;
                showMessageBox(`Whack-a-Mole Level Up! Now ${WHACK_A_MOLE_DIFFICULTY[whackAMoleLevel].name}!`, 'info', 2000);
            }
        }

        function startGame() {
            if (whackAMoleGameActive) return; // Prevent multiple starts
            
            whackAMoleGameActive = true;
            whackAMoleScore = 0;
            whackAMoleTimeLeft = 30;
            whackAMoleLevel = 1; // Reset level on new game start
            whackAMoleScoreDisplay.textContent = whackAMoleScore;
            whackAMoleTimerDisplay.textContent = `${whackAMoleTimeLeft}s`;
            whackAMoleGameOverScreen.classList.remove('active');
            whackAMoleStartButton.disabled = true; // Disable start button once game begins
            whackAMoleResetButton.disabled = false; // Enable reset button

            if (isAudioReady && whackAMoleBackgroundMusicLoop && whackAMoleBackgroundMusicLoop.state !== 'started') {
                whackAMoleBackgroundMusicLoop.start();
            }

            popRandomMole(); // Start moles popping
            timerInterval = setInterval(updateWhackAMoleTimer, 1000); // Start game timer
        }

        function updateWhackAMoleTimer() {
            whackAMoleTimeLeft--;
            whackAMoleTimerDisplay.textContent = `${whackAMoleTimeLeft}s`;

            if (whackAMoleTimeLeft <= 0) {
                endWhackAMoleGame();
            }
        }

        function endWhackAMoleGame() {
            whackAMoleGameActive = false;
            clearInterval(molePopInterval); // Stop moles from popping
            clearInterval(timerInterval); // Stop the timer
            moles.forEach(mole => {
                mole.classList.remove('up'); // Hide all moles
                mole.classList.remove('hit'); // Remove hit class
                clearTimeout(mole.moleTimeout); // Clear any pending mole timeouts
            });
            
            whackAMoleFinalScoreDisplay.textContent = whackAMoleScore;
            whackAMoleGameOverScreen.classList.add('active');
            whackAMoleStartButton.disabled = false; // Re-enable start button
            whackAMoleResetButton.disabled = false; // Ensure reset button is enabled

            // Update high score if current score is higher
            if (whackAMoleScore > whackAMoleHighScore) {
                whackAMoleHighScore = whackAMoleScore;
                localStorage.setItem('whackAMoleHighScore', whackAMoleHighScore);
            }
            whackAMoleHighScoreDisplay.textContent = whackAMoleHighScore; // Display the high score

            if (isAudioReady && whackAMoleGameOverSound && Tone.context.state === 'running') {
                whackAMoleGameOverSound.triggerAttackRelease("1n"); /* FIX: Corrected function name */
            }
            if (whackAMoleBackgroundMusicLoop && whackAMoleBackgroundMusicLoop.state === 'started') {
                whackAMoleBackgroundMusicLoop.stop();
            }
        }

        function resetWhackAMoleGame() {
            endWhackAMoleGame(); // Ensure all intervals are cleared and moles are hidden
            whackAMoleScore = 0;
            whackAMoleTimeLeft = 30;
            whackAMoleLevel = 1; // Reset level
            whackAMoleScoreDisplay.textContent = whackAMoleScore;
            whackAMoleTimerDisplay.textContent = `${whackAMoleTimeLeft}s`;
            whackAMoleGameOverScreen.classList.remove('active');
            whackAMoleStartButton.disabled = false; // Enable start button
            whackAMoleResetButton.disabled = false; // Enable reset button
            whackAMoleHighScore = parseInt(localStorage.getItem('whackAMoleHighScore') || '0'); // Reload high score on reset
            whackAMoleHighScoreDisplay.textContent = whackAMoleHighScore; // Update display
        }

        // Space Miner Game Logic
        let spaceMinerCanvas, spaceMinerCtx;
        let spaceship;
        let asteroids = [];
        let bullets = [];
        let spaceMinerScore = 0;
        let spaceMinerHighScore = 0;
        let spaceMinerGameActive = false;
        let animationFrameIdSpaceMiner;
        let keys = {}; // To track pressed keys
        let lastShotTime = 0;
        const SHOOT_COOLDOWN = 200; // milliseconds
        let asteroidSpawnInterval = 1000; // Initial asteroid spawn interval
        let lastAsteroidSpawnTime = 0;
        let spaceMinerScoreDisplay, spaceMinerHighScoreDisplay, spaceMinerGameOverScreen, spaceMinerFinalScoreDisplay, spaceMinerStartButton, spaceMinerResetButton, spaceMinerBackToGamesButton;
        let touchStartX = 0;
        let touchMoveX = 0;
        let touchMoving = false;
        let touchShootTimer = null;

        const SPACESHIP_WIDTH = 40;
        const SPACESHIP_HEIGHT = 40;
        const BULLET_RADIUS = 5;
        const BULLET_SPEED = 7;
        const ASTEROID_RADIUS_MIN = 15;
        const ASTEROID_RADIUS_MAX = 30;
        const ASTEROID_SPEED_MIN = 0.5;
        const ASTEROID_SPEED_MAX = 2;

        function initializeSpaceMinerGame() {
            stopAllGameMusic();
            if (isAudioReady && spaceMinerBackgroundMusicLoop && spaceMinerBackgroundMusicLoop.state !== 'started') {
                spaceMinerBackgroundMusicLoop.start();
            }

            const spaceMinerHtmlFragment = `
                <div class="game-container space-miner-game">
                    <h1>Space Miner</h1>
                    <div class="game-stats">
                        <div>Score: <span id="space-miner-score">0</span></div>
                        <div>High Score: <span id="space-miner-high-score">0</span></div>
                    </div>
                    <canvas id="spaceMinerCanvas" class="game-canvas" width="550" height="450"></canvas>
                    <div class="game-controls">
                        <button id="space-miner-start-button" class="button button-primary">Start Game</button>
                        <button id="space-miner-reset-button" class="button button-primary">Reset</button>
                    </div>
                    <button id="space-miner-back-to-games-button" class="button button-primary" style="margin-top: 20px;">Back to Games</button>

                    <div class="ad-placement glass-effect" style="margin-top: 20px;">
                        <p>Google Ad Placeholder: Space Miner Ad (e.g., 300x250)</p>
                    </div>

                    <div class="space-miner-game-over" id="space-miner-game-over">
                        <h2>Game Over!</h2>
                        <p>Final Score: <span id="space-miner-final-score">0</span></p>
                        <p>High Score: <span id="space-miner-game-over-high-score">0</span></p>
                        <button id="space-miner-restart-button" class="button button-primary">Play Again</button>
                    </div>
                </div>
            `;
            dynamicGameContainer.innerHTML = spaceMinerHtmlFragment;

            spaceMinerCanvas = dynamicGameContainer.querySelector('#spaceMinerCanvas');
            spaceMinerCtx = spaceMinerCanvas.getContext('2d');
            spaceMinerScoreDisplay = dynamicGameContainer.querySelector('#space-miner-score');
            spaceMinerHighScoreDisplay = dynamicGameContainer.querySelector('#space-miner-high-score');
            spaceMinerGameOverScreen = dynamicGameContainer.querySelector('#space-miner-game-over');
            spaceMinerFinalScoreDisplay = dynamicGameContainer.querySelector('#space-miner-final-score');
            spaceMinerStartButton = dynamicGameContainer.querySelector('#space-miner-start-button');
            spaceMinerResetButton = dynamicGameContainer.querySelector('#space-miner-reset-button');
            spaceMinerBackToGamesButton = dynamicGameContainer.querySelector('#space-miner-back-to-games-button');

            spaceMinerStartButton.addEventListener('click', startSpaceMinerGame);
            spaceMinerResetButton.addEventListener('click', resetSpaceMinerGame);
            spaceMinerGameOverScreen.querySelector('#space-miner-restart-button').addEventListener('click', resetSpaceMinerGame);
            spaceMinerBackToGamesButton.addEventListener('click', () => {
                stopAllGameMusic();
                if (typeof showPage === 'function') {
                    showPage('game-selection-page');
                } else {
                    console.warn("showPage function not found. Cannot navigate back to game selection.");
                    dynamicGameContainer.innerHTML = '';
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', handleSpaceMinerKeyDown);
            document.addEventListener('keyup', handleSpaceMinerKeyUp);

            // Touch controls
            spaceMinerCanvas.addEventListener('touchstart', handleSpaceMinerTouchStart);
            spaceMinerCanvas.addEventListener('touchmove', handleSpaceMinerTouchMove);
            spaceMinerCanvas.addEventListener('touchend', handleSpaceMinerTouchEnd);

            resetSpaceMinerGame(); // Initial setup
        }

        function resetSpaceMinerGame() {
            if (animationFrameIdSpaceMiner) {
                cancelAnimationFrame(animationFrameIdSpaceMiner);
            }
            spaceMinerGameActive = false;
            spaceship = {
                x: spaceMinerCanvas.width / 2 - SPACESHIP_WIDTH / 2,
                y: spaceMinerCanvas.height - SPACESHIP_HEIGHT - 20,
                width: SPACESHIP_WIDTH,
                height: SPACESHIP_HEIGHT,
                speed: 5
            };
            asteroids = [];
            bullets = [];
            spaceMinerScore = 0;
            spaceMinerScoreDisplay.textContent = spaceMinerScore;
            spaceMinerHighScore = parseInt(localStorage.getItem('spaceMinerHighScore') || '0');
            spaceMinerHighScoreDisplay.textContent = spaceMinerHighScore;
            spaceMinerGameOverScreen.classList.remove('active');
            spaceMinerStartButton.disabled = false;
            spaceMinerResetButton.disabled = false;
            asteroidSpawnInterval = 1000; // Reset difficulty
            lastAsteroidSpawnTime = 0;
            keys = {}; // Clear any held keys
            touchMoving = false;
            if (touchShootTimer) {
                clearInterval(touchShootTimer);
                touchShootTimer = null;
            }

            if (spaceMinerBackgroundMusicLoop && spaceMinerBackgroundMusicLoop.state === 'started') {
                spaceMinerBackgroundMusicLoop.stop();
            }
        }

        function startSpaceMinerGame() {
            if (spaceMinerGameActive) return;
            spaceMinerGameActive = true;
            spaceMinerStartButton.disabled = true;
            spaceMinerResetButton.disabled = false;
            spaceMinerGameOverScreen.classList.remove('active');
            spaceMinerScore = 0;
            spaceMinerScoreDisplay.textContent = spaceMinerScore;
            asteroids = [];
            bullets = [];
            asteroidSpawnInterval = 1000;
            lastAsteroidSpawnTime = Date.now();

            if (isAudioReady && spaceMinerBackgroundMusicLoop && spaceMinerBackgroundMusicLoop.state !== 'started') {
                spaceMinerBackgroundMusicLoop.start();
            }

            gameLoopSpaceMiner();
        }

        function gameLoopSpaceMiner() {
            if (!spaceMinerGameActive) return;

            updateSpaceMinerGame();
            drawSpaceMinerGame();

            animationFrameIdSpaceMiner = requestAnimationFrame(gameLoopSpaceMiner);
        }

        function drawSpaceMinerGame() {
            spaceMinerCtx.clearRect(0, 0, spaceMinerCanvas.width, spaceMinerCanvas.height);

            // Draw spaceship
            spaceMinerCtx.fillStyle = '#00BFFF'; // Deep Sky Blue
            spaceMinerCtx.beginPath();
            spaceMinerCtx.moveTo(spaceship.x + spaceship.width / 2, spaceship.y);
            spaceMinerCtx.lineTo(spaceship.x, spaceship.y + spaceship.height);
            spaceMinerCtx.lineTo(spaceship.x + spaceship.width, spaceship.y + spaceship.height);
            spaceMinerCtx.closePath();
            spaceMinerCtx.fill();
            spaceMinerCtx.strokeStyle = '#87CEEB';
            spaceMinerCtx.lineWidth = 2;
            spaceMinerCtx.stroke();

            // Draw bullets
            bullets.forEach(bullet => {
                spaceMinerCtx.fillStyle = '#FFD700'; // Gold
                spaceMinerCtx.beginPath();
                spaceMinerCtx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                spaceMinerCtx.fill();
            });

            // Draw asteroids
            asteroids.forEach(asteroid => {
                spaceMinerCtx.fillStyle = '#A9A9A9'; // DarkGray
                spaceMinerCtx.beginPath();
                // Draw a simple polygon for asteroid
                const sides = Math.floor(Math.random() * 3) + 5; // 5 to 7 sides
                const angleIncrement = (Math.PI * 2) / sides;
                for (let i = 0; i < sides; i++) {
                    const angle = i * angleIncrement;
                    const x = asteroid.x + asteroid.radius * Math.cos(angle);
                    const y = asteroid.y + asteroid.radius * Math.sin(angle);
                    if (i === 0) {
                        spaceMinerCtx.moveTo(x, y);
                    } else {
                        spaceMinerCtx.lineTo(x, y);
                    }
                }
                spaceMinerCtx.closePath();
                spaceMinerCtx.fill();
                spaceMinerCtx.strokeStyle = '#696969'; // DimGray
                spaceMinerCtx.lineWidth = 2;
                spaceMinerCtx.stroke();
            });
        }

        function updateSpaceMinerGame() {
            // Move spaceship
            if (keys['ArrowLeft'] || keys['a']) {
                spaceship.x -= spaceship.speed;
            }
            if (keys['ArrowRight'] || keys['d']) {
                spaceship.x += spaceship.speed;
            }
            // Clamp spaceship position
            if (spaceship.x < 0) spaceship.x = 0;
            if (spaceship.x + spaceship.width > spaceMinerCanvas.width) spaceship.x = spaceMinerCanvas.width - spaceship.width;

            // Move bullets
            bullets.forEach(bullet => {
                bullet.y -= BULLET_SPEED;
            });
            bullets = bullets.filter(bullet => bullet.y + bullet.radius > 0); // Remove off-screen bullets

            // Spawn asteroids
            const currentTime = Date.now();
            if (currentTime - lastAsteroidSpawnTime > asteroidSpawnInterval) {
                spawnAsteroid();
                lastAsteroidSpawnTime = currentTime;
                // Gradually decrease spawn interval to increase difficulty
                asteroidSpawnInterval = Math.max(200, asteroidSpawnInterval * 0.98);
            }

            // Move asteroids
            asteroids.forEach(asteroid => {
                asteroid.y += asteroid.speed;
            });
            asteroids = asteroids.filter(asteroid => {
                // Check if asteroid hits bottom
                if (asteroid.y - asteroid.radius > spaceMinerCanvas.height) {
                    endSpaceMinerGame(); // Game over if asteroid reaches bottom
                    return false;
                }
                return true;
            });

            // Collision detection: Bullets vs Asteroids
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const bullet = bullets[i];
                    const asteroid = asteroids[j];

                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bullet.radius + asteroid.radius) {
                        // Collision!
                        bullets.splice(i, 1); // Remove bullet
                        asteroids.splice(j, 1); // Remove asteroid
                        spaceMinerScore += 10; // Increase score
                        spaceMinerScoreDisplay.textContent = spaceMinerScore;
                        if (isAudioReady && explosionSound && Tone.context.state === 'running') {
                            explosionSound.triggerAttackRelease("8n");
                        }
                        // Ensure i doesn't go out of bounds if a bullet was removed
                        if (i > bullets.length - 1) i = bullets.length - 1;
                        break; // Move to next bullet after collision
                    }
                }
            }

            // Collision detection: Spaceship vs Asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                // Simple AABB collision for now
                if (
                    spaceship.x < asteroid.x + asteroid.radius &&
                    spaceship.x + spaceship.width > asteroid.x - asteroid.radius &&
                    spaceship.y < asteroid.y + asteroid.radius &&
                    spaceship.y + spaceship.height > asteroid.y - asteroid.radius
                ) {
                    endSpaceMinerGame(); // Game over if spaceship hits asteroid
                    return; // Exit update loop immediately
                }
            }

            // Automatic shooting for touch if touch is active and not moving
            if (touchMoving === false && (keys['Space'] || touchShootTimer)) { // Only shoot if space is pressed or touch shoot is active
                shootBullet();
            }
        }

        function spawnAsteroid() {
            const radius = getRandomInt(ASTEROID_RADIUS_MIN, ASTEROID_RADIUS_MAX);
            const x = Math.random() * (spaceMinerCanvas.width - radius * 2) + radius;
            const y = -radius; // Start above canvas
            const speed = getRandomInt(ASTEROID_SPEED_MIN * 10, ASTEROID_SPEED_MAX * 10) / 10;
            asteroids.push({ x, y, radius, speed });
        }

        function shootBullet() {
            const currentTime = Date.now();
            if (currentTime - lastShotTime > SHOOT_COOLDOWN) {
                const x = spaceship.x + spaceship.width / 2;
                const y = spaceship.y;
                bullets.push({ x, y, radius: BULLET_RADIUS });
                lastShotTime = currentTime;
                if (isAudioReady && shootSound && Tone.context.state === 'running') {
                    shootSound.triggerAttackRelease("C5", "32n");
                }
            }
        }

        function handleSpaceMinerKeyDown(e) {
            if (!spaceMinerGameActive) return;
            keys[e.key] = true;
            if (e.key === ' ') { // Prevent scrolling when space is pressed
                e.preventDefault();
            }
        }

        function handleSpaceMinerKeyUp(e) {
            if (!spaceMinerGameActive) return;
            keys[e.key] = false;
        }

        function handleSpaceMinerTouchStart(e) {
            if (!spaceMinerGameActive) return;
            e.preventDefault(); // Prevent scrolling/zooming

            touchStartX = e.touches[0].clientX;
            touchMoveX = e.touches[0].clientX;
            touchMoving = false; // Assume not moving initially

            // Start continuous shooting on touch
            if (!touchShootTimer) {
                touchShootTimer = setInterval(shootBullet, SHOOT_COOLDOWN);
            }
        }

        function handleSpaceMinerTouchMove(e) {
            if (!spaceMinerGameActive) return;
            e.preventDefault();

            const currentX = e.touches[0].clientX;
            const deltaX = currentX - touchMoveX;

            // Move spaceship based on touch delta
            spaceship.x += deltaX * 0.5; // Adjust sensitivity
            
            // Clamp spaceship position
            if (spaceship.x < 0) spaceship.x = 0;
            if (spaceship.x + spaceship.width > spaceMinerCanvas.width) spaceship.x = spaceMinerCanvas.width - spaceship.width;

            touchMoveX = currentX;
            touchMoving = true; // User is actively moving
        }

        function handleSpaceMinerTouchEnd(e) {
            if (!spaceMinerGameActive) return;
            // Stop continuous shooting on touch end
            if (touchShootTimer) {
                clearInterval(touchShootTimer);
                touchShootTimer = null;
            }
            touchMoving = false; // Reset moving flag
        }

        function endSpaceMinerGame() {
            spaceMinerGameActive = false;
            if (animationFrameIdSpaceMiner) {
                cancelAnimationFrame(animationFrameIdSpaceMiner);
            }
            if (touchShootTimer) {
                clearInterval(touchShootTimer);
                touchShootTimer = null;
            }

            spaceMinerFinalScoreDisplay.textContent = spaceMinerScore;
            if (spaceMinerScore > spaceMinerHighScore) {
                spaceMinerHighScore = spaceMinerScore;
                localStorage.setItem('spaceMinerHighScore', spaceMinerHighScore);
            }
            dynamicGameContainer.querySelector('#space-miner-game-over-high-score').textContent = spaceMinerHighScore;
            spaceMinerGameOverScreen.classList.add('active');
            spaceMinerStartButton.disabled = false; // Re-enable start button
            spaceMinerResetButton.disabled = false; // Ensure reset button is enabled

            if (spaceMinerBackgroundMusicLoop && spaceMinerBackgroundMusicLoop.state === 'started') {
                spaceMinerBackgroundMusicLoop.stop();
            }
        }

        // City Runner Game Logic (2D)
        let cityRunnerCanvas, cityRunnerCtx;
        let cityRunnerPlayer;
        let cityRunnerObstacles = [];
        let cityRunnerScore = 0;
        let cityRunnerHighScore = 0;
        let cityRunnerGameActive = false;
        let animationFrameIdCityRunner;
        let cityRunnerKeys = {};
        let lastObstacleSpawnTimeCityRunner = 0;
        let cityRunnerGameSpeed = 3; // Initial speed
        const CITY_RUNNER_GRAVITY = 0.3;
        const CITY_RUNNER_JUMP_STRENGTH = -7;
        const CITY_RUNNER_PLAYER_WIDTH = 30;
        const CITY_RUNNER_PLAYER_HEIGHT = 60;
        const CITY_RUNNER_GROUND_Y = 350; // Y-coordinate of the ground
        const CITY_RUNNER_OBSTACLE_WIDTH = 25; // Adjusted for spiky obstacle
        const CITY_RUNNER_OBSTACLE_HEIGHT = 50; // Adjusted for spiky obstacle
        const CITY_RUNNER_SPAWN_INTERVAL_MIN = 1000;
        const CITY_RUNNER_SPAWN_INTERVAL_MAX = 2500;
        const CITY_RUNNER_SPEED_INCREASE_INTERVAL = 5000; // Increase speed every 5 seconds
        const CITY_RUNNER_MAX_SPEED = 8;
        let lastSpeedIncreaseTimeCityRunner = 0;
        let cityRunnerFrame = 0; // For player animation
        const CITY_RUNNER_ANIMATION_SPEED = 5; // Frames per animation cycle

        // City Runner UI elements
        let cityRunnerScoreDisplay, cityRunnerHighScoreDisplay, cityRunnerGameOverScreen, cityRunnerFinalScoreDisplay, cityRunnerStartButton, cityRunnerResetButton, cityRunnerBackToGamesButton;

        function initializeCityRunnerGame() {
            stopAllGameMusic();
            if (isAudioReady && cityRunnerBackgroundMusicLoop && cityRunnerBackgroundMusicLoop.state !== 'started') {
                cityRunnerBackgroundMusicLoop.start();
            }

            const cityRunnerHtmlFragment = `
                <div class="game-container city-runner-game">
                    <h1>City Runner</h1>
                    <div class="game-stats">
                        <div>Score: <span id="city-runner-score">0</span></div>
                        <div>High Score: <span id="city-runner-high-score">0</span></div>
                    </div>
                    <canvas id="cityRunnerCanvas" class="game-canvas" width="550" height="400"></canvas>
                    <div class="game-controls">
                        <button id="city-runner-start-button" class="button button-primary">Start Game</button>
                        <button id="city-runner-reset-button" class="button button-primary">Reset</button>
                    </div>
                    <button id="city-runner-back-to-games-button" class="button button-primary" style="margin-top: 20px;">Back to Games</button>

                    <div class="ad-placement glass-effect" style="margin-top: 20px;">
                        <p>Google Ad Placeholder: City Runner Ad (e.g., 300x250)</p>
                    </div>

                    <div class="city-runner-game-over" id="city-runner-game-over">
                        <h2>Game Over!</h2>
                        <p>Final Score: <span id="city-runner-final-score">0</span></p>
                        <p>High Score: <span id="city-runner-game-over-high-score">0</span></p>
                        <button id="city-runner-restart-button" class="button button-primary">Play Again</button>
                    </div>
                </div>
            `;
            dynamicGameContainer.innerHTML = cityRunnerHtmlFragment;

            cityRunnerCanvas = dynamicGameContainer.querySelector('#cityRunnerCanvas');
            cityRunnerCtx = cityRunnerCanvas.getContext('2d');
            cityRunnerScoreDisplay = dynamicGameContainer.querySelector('#city-runner-score');
            cityRunnerHighScoreDisplay = dynamicGameContainer.querySelector('#city-runner-high-score');
            cityRunnerGameOverScreen = dynamicGameContainer.querySelector('#city-runner-game-over');
            cityRunnerFinalScoreDisplay = dynamicGameContainer.querySelector('#city-runner-final-score');
            cityRunnerStartButton = dynamicGameContainer.querySelector('#city-runner-start-button');
            cityRunnerResetButton = dynamicGameContainer.querySelector('#city-runner-reset-button');
            cityRunnerBackToGamesButton = dynamicGameContainer.querySelector('#city-runner-back-to-games-button');

            cityRunnerStartButton.addEventListener('click', startCityRunnerGame);
            cityRunnerResetButton.addEventListener('click', resetCityRunnerGame);
            cityRunnerGameOverScreen.querySelector('#city-runner-restart-button').addEventListener('click', () => {
                resetCityRunnerGame();
                startCityRunnerGame();
            });
            cityRunnerBackToGamesButton.addEventListener('click', () => {
                stopAllGameMusic();
                if (typeof showPage === 'function') {
                    showPage('game-selection-page');
                } else {
                    console.warn("showPage function not found. Cannot navigate back to game selection.");
                    dynamicGameContainer.innerHTML = '';
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', handleCityRunnerKeyDown);
            document.addEventListener('keyup', handleCityRunnerKeyUp);

            // Touch controls (tap to jump)
            cityRunnerCanvas.addEventListener('touchstart', handleCityRunnerTouchStart);

            resetCityRunnerGame(); // Initial setup
        }

        function resetCityRunnerGame() {
            if (animationFrameIdCityRunner) {
                cancelAnimationFrame(animationFrameIdCityRunner);
            }
            cityRunnerGameActive = false;
            cityRunnerPlayer = {
                x: 50,
                y: CITY_RUNNER_GROUND_Y - CITY_RUNNER_PLAYER_HEIGHT,
                width: CITY_RUNNER_PLAYER_WIDTH,
                height: CITY_RUNNER_PLAYER_HEIGHT,
                velocityY: 0,
                isJumping: false,
                frame: 0 // Initialize animation frame
            };
            cityRunnerObstacles = [];
            cityRunnerScore = 0;
            cityRunnerScoreDisplay.textContent = cityRunnerScore;
            cityRunnerHighScore = parseInt(localStorage.getItem('cityRunnerHighScore') || '0');
            cityRunnerHighScoreDisplay.textContent = cityRunnerHighScore;
            cityRunnerGameOverScreen.classList.remove('active');
            cityRunnerStartButton.disabled = false;
            cityRunnerResetButton.disabled = false;
            cityRunnerGameSpeed = 3; // Reset speed
            lastObstacleSpawnTimeCityRunner = 0;
            lastSpeedIncreaseTimeCityRunner = 0;
            cityRunnerKeys = {};

            if (cityRunnerBackgroundMusicLoop && cityRunnerBackgroundMusicLoop.state === 'started') {
                cityRunnerBackgroundMusicLoop.stop();
            }
            drawCityRunnerGame(); // Initial render of the empty game
        }

        function startCityRunnerGame() {
            if (cityRunnerGameActive) return;
            cityRunnerGameActive = true;
            cityRunnerStartButton.disabled = true;
            cityRunnerResetButton.disabled = false;
            cityRunnerGameOverScreen.classList.remove('active');
            cityRunnerScore = 0;
            cityRunnerScoreDisplay.textContent = cityRunnerScore;
            cityRunnerObstacles = [];
            cityRunnerGameSpeed = 3;
            lastObstacleSpawnTimeCityRunner = Date.now();
            lastSpeedIncreaseTimeCityRunner = Date.now();

            if (isAudioReady && cityRunnerBackgroundMusicLoop && cityRunnerBackgroundMusicLoop.state !== 'started') {
                cityRunnerBackgroundMusicLoop.start();
            }

            cityRunnerGameLoop();
        }

        function cityRunnerGameLoop() {
            if (!cityRunnerGameActive) return;

            updateCityRunnerGame();
            drawCityRunnerGame();

            animationFrameIdCityRunner = requestAnimationFrame(cityRunnerGameLoop);
        }

        // Function to draw the hero character
        function drawHero(ctx, player) {
            const x = player.x;
            const y = player.y;
            const width = player.width;
            const height = player.height;

            // Base colors
            const bodyColor = '#3498DB'; // Hero blue
            const bodyDark = '#2980B9'; // Darker blue for shading
            const skinColor = '#FFDBAC'; // Light skin tone
            const skinDark = '#C0A080'; // Darker skin tone for outline
            const shoeColor = '#2C3E50'; // Dark grey
            const shoeDark = '#1C2833'; // Even darker grey

            // Shadow beneath the character
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + width / 2, CITY_RUNNER_GROUND_Y + 5, width * 0.8, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (circle with gradient)
            const headRadius = width * 0.4;
            ctx.save();
            ctx.beginPath();
            ctx.arc(x + width / 2, y + headRadius, headRadius, 0, Math.PI * 2);
            ctx.closePath();
            const headGradient = ctx.createRadialGradient(x + width / 2 - headRadius * 0.3, y + headRadius - headRadius * 0.3, 0, x + width / 2, y + headRadius, headRadius);
            headGradient.addColorStop(0, '#FFF5EE'); // Lighter skin
            headGradient.addColorStop(1, skinColor);
            ctx.fillStyle = headGradient;
            ctx.fill();
            ctx.strokeStyle = skinDark; // Skin outline
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Eyes (simple dots with white highlight)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + width * 0.35, y + headRadius * 0.8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + width * 0.65, y + headRadius * 0.8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + width * 0.36, y + headRadius * 0.78, 0.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + width * 0.66, y + headRadius * 0.78, 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (simple line)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x + width / 2, y + headRadius * 1.2, headRadius * 0.3, 0, Math.PI);
            ctx.stroke();
            ctx.restore();

            // Torso (rounded rectangle with gradient)
            ctx.save();
            ctx.beginPath();
            ctx.roundRect(x, y + height * 0.2, width, height * 0.6, 5);
            ctx.closePath();
            const bodyGradient = ctx.createLinearGradient(x, y + height * 0.2, x + width, y + height * 0.2);
            bodyGradient.addColorStop(0, bodyDark);
            bodyGradient.addColorStop(0.5, bodyColor);
            bodyGradient.addColorStop(1, bodyDark);
            ctx.fillStyle = bodyGradient;
            ctx.fill();
            ctx.strokeStyle = bodyDark; // Darker blue outline
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Arms (animated)
            const armLength = width * 0.7;
            const armWidth = width * 0.2;
            const armYOffset = y + height * 0.3;

            // Reset shadow for arms and legs
            ctx.shadowColor = 'transparent';

            if (player.isJumping) {
                // Jumping pose: arms raised
                ctx.fillStyle = bodyColor;
                ctx.strokeStyle = bodyDark;
                ctx.beginPath(); // Left arm
                ctx.roundRect(x - armWidth, armYOffset - armLength * 0.5, armWidth, armLength, 3);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath(); // Right arm
                ctx.roundRect(x + width, armYOffset - armLength * 0.5, armWidth, armLength, 3);
                ctx.fill();
                ctx.stroke();
            } else {
                // Running animation: arms swinging
                const armSwing = Math.sin(player.frame / CITY_RUNNER_ANIMATION_SPEED * Math.PI) * (width * 0.2);

                // Front arm (appears to be swinging forward)
                ctx.fillStyle = bodyColor;
                ctx.strokeStyle = bodyDark;
                ctx.beginPath();
                ctx.roundRect(x + width - armWidth, armYOffset + armSwing, armWidth, armLength, 3);
                ctx.fill();
                ctx.stroke();

                // Back arm (appears to be swinging backward)
                ctx.beginPath();
                ctx.roundRect(x, armYOffset - armSwing, armWidth, armLength, 3);
                ctx.fill();
                ctx.stroke();
            }

            // Legs (animated)
            ctx.fillStyle = shoeColor;
            ctx.strokeStyle = shoeDark;
            ctx.lineWidth = 2;

            const legHeight = height * 0.3;
            const legWidth = width * 0.4;
            const legY = y + height * 0.8;

            if (player.isJumping) {
                // Jumping pose: legs tucked
                ctx.beginPath();
                ctx.roundRect(x + width * 0.1, legY - 10, legWidth, legHeight, 3);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.roundRect(x + width * 0.5, legY - 10, legWidth, legHeight, 3);
                ctx.fill();
                ctx.stroke();
            } else {
                // Running animation
                const legOffset = Math.sin(player.frame / CITY_RUNNER_ANIMATION_SPEED) * (width * 0.1);

                // Front leg
                ctx.beginPath();
                ctx.roundRect(x + width * 0.1 + legOffset, legY, legWidth, legHeight, 3);
                ctx.fill();
                ctx.stroke();

                // Back leg
                ctx.beginPath();
                ctx.roundRect(x + width * 0.5 - legOffset, legY, legWidth, legHeight, 3);
                ctx.fill();
                ctx.stroke();
            }
        }

        // Function to draw the evil obstacle character (spiky block)
        function drawObstacle(ctx, obstacle) {
            const x = obstacle.x;
            const y = obstacle.y;
            const width = obstacle.width;
            const height = obstacle.height;

            const mainColor = '#E74C3C'; // Red
            const highlightColor = '#FF6347'; // Tomato
            const outlineColor = '#A93226'; // Even darker red
            const spikeColor = '#C0392B'; // Darker red (Moved this declaration to here)
            const eyeColor = '#FFD700'; // Gold for evil eyes
            const glowColor = 'rgba(255, 0, 0, 0.4)'; // Red glow

            // Apply glow effect
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 15; // Increased blur for stronger glow
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main body (rectangle with gradient)
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
            gradient.addColorStop(0, highlightColor);
            gradient.addColorStop(0.5, mainColor);
            gradient.addColorStop(1, outlineColor);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Spikes on top (more defined and irregular)
            const numSpikes = 4; // More spikes
            const spikeBaseWidth = width / numSpikes;
            const spikeHeight = 15; // Height of spikes

            for (let i = 0; i < numSpikes; i++) {
                ctx.fillStyle = spikeColor;
                ctx.beginPath();
                ctx.moveTo(x + i * spikeBaseWidth, y);
                ctx.lineTo(x + i * spikeBaseWidth + spikeBaseWidth * 0.4, y - spikeHeight);
                ctx.lineTo(x + (i + 1) * spikeBaseWidth, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Evil Eyes (glowing)
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)'; // Yellowish glow for eyes
            ctx.shadowBlur = 10;
            ctx.fillStyle = eyeColor;
            
            // Left eye
            ctx.beginPath();
            ctx.arc(x + width * 0.3, y + height * 0.3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Right eye
            ctx.beginPath();
            ctx.arc(x + width * 0.7, y + height * 0.3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }


        function drawCityRunnerGame() {
            cityRunnerCtx.clearRect(0, 0, cityRunnerCanvas.width, cityRunnerCanvas.height);

            // Draw ground
            cityRunnerCtx.fillStyle = '#6B4226'; // Brown
            cityRunnerCtx.fillRect(0, CITY_RUNNER_GROUND_Y, cityRunnerCanvas.width, cityRunnerCanvas.height - CITY_RUNNER_GROUND_Y);

            // Draw city background (simple rectangles for buildings)
            cityRunnerCtx.fillStyle = '#7F8C8D'; // Gray for buildings
            // Draw buildings that scroll
            for (let i = 0; i < 5; i++) { // Draw a few buildings
                const buildingWidth = 80 + Math.random() * 50;
                const buildingHeight = 100 + Math.random() * 80;
                const buildingX = (i * 150 + (Date.now() * 0.05 * cityRunnerGameSpeed)) % (cityRunnerCanvas.width + buildingWidth) - buildingWidth;
                cityRunnerCtx.fillRect(buildingX, CITY_RUNNER_GROUND_Y - buildingHeight, buildingWidth, buildingHeight);
                cityRunnerCtx.fillStyle = '#95A5A6'; // Darker gray for windows
                cityRunnerCtx.fillRect(buildingX + 10, CITY_RUNNER_GROUND_Y - buildingHeight + 10, 10, 10);
                cityRunnerCtx.fillRect(buildingX + 30, CITY_RUNNER_GROUND_Y - buildingHeight + 10, 10, 10);
                cityRunnerCtx.fillRect(buildingX + 10, CITY_RUNNER_GROUND_Y - buildingHeight + 30, 10, 10);
                cityRunnerCtx.fillRect(buildingX + 30, CITY_RUNNER_GROUND_Y - buildingHeight + 30, 10, 10);
                cityRunnerCtx.fillStyle = '#7F8C8D'; // Reset to building color
            }


            // Draw player using the new function
            drawHero(cityRunnerCtx, cityRunnerPlayer);

            // Draw obstacles using the new function
            cityRunnerObstacles.forEach(obstacle => {
                drawObstacle(cityRunnerCtx, obstacle);
            });
        }

        function updateCityRunnerGame() {
            // Player vertical movement
            if (cityRunnerPlayer.isJumping) {
                cityRunnerPlayer.velocityY += CITY_RUNNER_GRAVITY;
                cityRunnerPlayer.y += cityRunnerPlayer.velocityY;

                // Land on ground
                if (cityRunnerPlayer.y + cityRunnerPlayer.height > CITY_RUNNER_GROUND_Y) {
                    cityRunnerPlayer.y = CITY_RUNNER_GROUND_Y - cityRunnerPlayer.height;
                    cityRunnerPlayer.velocityY = 0;
                    cityRunnerPlayer.isJumping = false;
                }
            } else {
                // Update animation frame for running
                cityRunnerPlayer.frame = (cityRunnerPlayer.frame + 1) % (CITY_RUNNER_ANIMATION_SPEED * 2); // Cycle through frames
            }

            // Increase game speed over time
            const currentTime = Date.now();
            if (currentTime - lastSpeedIncreaseTimeCityRunner > CITY_RUNNER_SPEED_INCREASE_INTERVAL) {
                cityRunnerGameSpeed = Math.min(CITY_RUNNER_MAX_SPEED, cityRunnerGameSpeed + 0.5);
                lastSpeedIncreaseTimeCityRunner = currentTime;
            }

            // Spawn obstacles
            if (currentTime - lastObstacleSpawnTimeCityRunner > getRandomInt(CITY_RUNNER_SPAWN_INTERVAL_MIN, CITY_RUNNER_SPAWN_INTERVAL_MAX)) {
                spawnCityRunnerObstacle();
                lastObstacleSpawnTimeCityRunner = currentTime;
            }

            // Move obstacles
            cityRunnerObstacles.forEach(obstacle => {
                obstacle.x -= cityRunnerGameSpeed;
            });
            cityRunnerObstacles = cityRunnerObstacles.filter(obstacle => {
                // Remove obstacles that are off-screen and update score
                if (obstacle.x + obstacle.width < 0) {
                    cityRunnerScore += 10;
                    cityRunnerScoreDisplay.textContent = cityRunnerScore;
                    return false;
                }
                return true;
            });

            // Collision detection (Player vs Obstacles)
            cityRunnerObstacles.forEach(obstacle => {
                // Adjust collision box for the more detailed player and obstacle shapes
                // This is a simplified AABB collision, might need fine-tuning with complex shapes
                if (
                    cityRunnerPlayer.x < obstacle.x + obstacle.width &&
                    cityRunnerPlayer.x + cityRunnerPlayer.width > obstacle.x &&
                    cityRunnerPlayer.y + cityRunnerPlayer.height * 0.2 < obstacle.y + obstacle.height && // Adjust player top for head
                    cityRunnerPlayer.y + cityRunnerPlayer.height > obstacle.y
                ) {
                    endCityRunnerGame(); // Collision detected
                }
            });
        }

        function spawnCityRunnerObstacle() {
            const obstacleHeight = CITY_RUNNER_OBSTACLE_HEIGHT;
            const obstacleY = CITY_RUNNER_GROUND_Y - obstacleHeight;
            cityRunnerObstacles.push({
                x: cityRunnerCanvas.width,
                y: obstacleY,
                width: CITY_RUNNER_OBSTACLE_WIDTH,
                height: obstacleHeight
            });
        }

        function handleCityRunnerKeyDown(e) {
            if (!cityRunnerGameActive) return;
            cityRunnerKeys[e.key] = true;
            if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') && !cityRunnerPlayer.isJumping) {
                cityRunnerPlayer.isJumping = true;
                cityRunnerPlayer.velocityY = CITY_RUNNER_JUMP_STRENGTH;
                if (isAudioReady && cityRunnerJumpSound && Tone.context.state === 'running') {
                    cityRunnerJumpSound.triggerAttackRelease("C5", "16n");
                }
            }
            // Prevent default scrolling for spacebar and arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }

        function handleCityRunnerKeyUp(e) {
            if (!cityRunnerGameActive) return;
            cityRunnerKeys[e.key] = false;
        }

        function handleCityRunnerTouchStart(e) {
            if (!cityRunnerGameActive) return;
            e.preventDefault(); // Prevent scrolling
            if (!cityRunnerPlayer.isJumping) {
                cityRunnerPlayer.isJumping = true;
                cityRunnerPlayer.velocityY = CITY_RUNNER_JUMP_STRENGTH;
                if (isAudioReady && cityRunnerJumpSound && Tone.context.state === 'running') {
                    cityRunnerJumpSound.triggerAttackRelease("C5", "16n");
                }
            }
        }

        function endCityRunnerGame() {
            cityRunnerGameActive = false;
            if (animationFrameIdCityRunner) {
                cancelAnimationFrame(animationFrameIdCityRunner);
            }
            if (isAudioReady && cityRunnerCollisionSound && Tone.context.state === 'running') {
                cityRunnerCollisionSound.triggerAttackRelease("8n");
            }

            cityRunnerFinalScoreDisplay.textContent = cityRunnerScore;
            if (cityRunnerScore > cityRunnerHighScore) {
                cityRunnerHighScore = cityRunnerScore;
                localStorage.setItem('cityRunnerHighScore', cityRunnerHighScore);
            }
            dynamicGameContainer.querySelector('#city-runner-game-over-high-score').textContent = cityRunnerHighScore;
            cityRunnerGameOverScreen.classList.add('active');
            cityRunnerStartButton.disabled = false; // Re-enable start button
            cityRunnerResetButton.disabled = false; // Ensure reset button is enabled

            if (cityRunnerBackgroundMusicLoop && cityRunnerBackgroundMusicLoop.state === 'started') {
                cityRunnerBackgroundMusicLoop.stop();
            }
        }


        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --------------------------------------------------------------------
        // Smart Notepad Logic
        // --------------------------------------------------------------------
        let notes = []; // Array to store all note objects
        let subjects = new Set(); // To store unique subjects for filtering
        let thoughtDumpContent = "";
        let currentFilter = {
            subject: 'all',
            tag: 'all',
            date: 'all',
            todoPending: false,
            archived: false
        };
        let currentSort = 'newest';
        let focusedNoteId = null; // Track the ID of the currently focused note

        // DOM Elements for Notepad
        let notepadContainer, addNoteSection, notesList, noNotesMessage;
        let noteTitleInput, noteSubjectInput, noteContentTextarea, noteTagCheckboxes;
        let addNoteButton, clearFormButton;
        let subjectSuggestionsDatalist;
        let filterSubjectSelect, sortDateSelect, filterTodayButton, filterImportantButton, filterReviseButton, filterTodoPendingButton, filterArchivedButton, clearFiltersButton;
        let progressTrackerSection, completedTasksPercentage, progressBarFill;
        let thoughtDumpTextarea, clearThoughtDumpButton;
        let focusModeToggleButton;
        let exportNoteButton, backupAllNotesButton;

        const SUBJECT_COLORS = {
            'math': 'var(--subject-math)',
            'physics': 'var(--subject-physics)',
            'coding': 'var(--subject-coding)',
            'chemistry': 'var(--subject-chemistry)',
            'history': 'var(--subject-history)',
            'literature': 'var(--subject-literature)',
            'biology': 'var(--subject-biology)',
            'art': 'var(--subject-art)',
            'other': 'var(--subject-other)'
        };

        function loadNotepadData() {
            notes = JSON.parse(localStorage.getItem('smartNotes')) || [];
            subjects = new Set(); // Clear existing subjects before repopulating
            notes.forEach(note => {
                if (note.subject) subjects.add(note.subject);
                // Ensure checklist items have 'completed' property
                if (note.checklist) {
                    note.checklist = note.checklist.map(item => ({ text: item.text, completed: item.completed || false }));
                }
            });
            thoughtDumpContent = localStorage.getItem('thoughtDump') || "";

            // Check for daily clear for thought dump
            const lastClearDate = localStorage.getItem('lastThoughtDumpClearDate');
            const today = new Date().toDateString();
            if (lastClearDate !== today) {
                thoughtDumpContent = "";
                localStorage.setItem('thoughtDump', "");
                localStorage.setItem('lastThoughtDumpClearDate', today);
            }
        }

        function saveNotepadData() {
            localStorage.setItem('smartNotes', JSON.stringify(notes));
            localStorage.setItem('thoughtDump', thoughtDumpContent);
            renderNotes(); // Re-render notes after saving
            updateProgressTracker(); // Update progress tracker
            updateSubjectFilterOptions(); // Update subject filter dropdown
        }

        function addNote() {
            const title = noteTitleInput.value.trim();
            const subject = noteSubjectInput.value.trim();
            const content = noteContentTextarea.value.trim();
            const tags = Array.from(noteTagCheckboxes)
                            .filter(checkbox => checkbox.checked)
                            .map(checkbox => checkbox.dataset.tag);

            if (!title || !content) {
                showMessageBox('Please enter both a title and content for your note.', 'error');
                return;
            }

            const newNote = {
                id: Date.now().toString(), // Unique ID
                title,
                subject: subject || 'Other', // Default subject
                content,
                tags,
                createdAt: new Date().toISOString(),
                isArchived: false,
                checklist: parseChecklistFromContent(content)
            };

            notes.push(newNote);
            subjects.add(newNote.subject); // Add new subject to the set
            saveNotepadData();
            clearNoteForm();
            showMessageBox('Note added successfully!', 'success');
        }

        function parseChecklistFromContent(content) {
            const checklistRegex = /\[(x| )\]\s*(.*)/g;
            let match;
            const checklistItems = [];
            while ((match = checklistRegex.exec(content)) !== null) {
                checklistItems.push({
                    text: match[2].trim(),
                    completed: match[1] === 'x'
                });
            }
            return checklistItems;
        }

        function updateNoteContentWithChecklist(noteId, checklistItemIndex, isCompleted) {
            const note = notes.find(n => n.id === noteId);
            if (note && note.checklist && note.checklist[checklistItemIndex]) {
                note.checklist[checklistItemIndex].completed = isCompleted;

                // Update the original content string to reflect the change
                let updatedContent = note.content;
                const checklistRegex = /\[(x| )\]\s*(.*)/g;
                let matchCount = 0;
                updatedContent = updatedContent.replace(checklistRegex, (match, p1, p2) => {
                    if (matchCount === checklistItemIndex) {
                        return `[${isCompleted ? 'x' : ' '}] ${p2}`;
                    }
                    matchCount++;
                    return match;
                });
                note.content = updatedContent;
                saveNotepadData();
            }
        }


        function renderNotes() {
            notesList.innerHTML = ''; // Clear current notes
            noNotesMessage.style.display = 'none'; // Hide no notes message by default

            let filteredNotes = [...notes]; // Create a shallow copy to filter

            // Apply filters
            if (currentFilter.subject !== 'all') {
                filteredNotes = filteredNotes.filter(note => note.subject === currentFilter.subject);
            }
            if (currentFilter.tag !== 'all') {
                filteredNotes = filteredNotes.filter(note => note.tags.includes(currentFilter.tag));
            }
            if (currentFilter.date === 'today') {
                const today = new Date().toDateString();
                filteredNotes = filteredNotes.filter(note => new Date(note.createdAt).toDateString() === today);
            }
            if (currentFilter.todoPending) {
                filteredNotes = filteredNotes.filter(note => 
                    note.checklist && note.checklist.some(item => !item.completed)
                );
            }
            if (!currentFilter.archived) { // If not filtering by archived, hide archived notes
                filteredNotes = filteredNotes.filter(note => !note.isArchived);
            } else { // If filtering by archived, only show archived notes
                filteredNotes = filteredNotes.filter(note => note.isArchived);
            }

            // Apply sorting
            filteredNotes.sort((a, b) => {
                const dateA = new Date(a.createdAt);
                const dateB = new Date(b.createdAt);
                if (currentSort === 'newest') {
                    return dateB - dateA;
                } else {
                    return dateA - dateB;
                }
            });

            if (filteredNotes.length === 0) {
                noNotesMessage.style.display = 'block';
                return;
            }

            filteredNotes.forEach(note => {
                const noteCard = document.createElement('div');
                noteCard.classList.add('note-card');
                noteCard.dataset.id = note.id;
                if (note.isArchived) {
                    noteCard.classList.add('archived');
                }
                noteCard.classList.add(`subject-${note.subject.toLowerCase().replace(/\s/g, '-')}`); // Add subject class for color-coding

                const formattedDate = new Date(note.createdAt).toLocaleString();

                let tagsHtml = '';
                if (note.tags && note.tags.length > 0) {
                    tagsHtml = `<div class="note-tags">` +
                                note.tags.map(tag => `<span class="note-tag">${getTagNameWithIcon(tag)}</span>`).join('') +
                                `</div>`;
                }

                let checklistHtml = '';
                if (note.checklist && note.checklist.length > 0) {
                    checklistHtml = `<ul class="note-checklist">` +
                                    note.checklist.map((item, index) => `
                                        <li class="${item.completed ? 'completed' : ''}">
                                            <input type="checkbox" data-note-id="${note.id}" data-checklist-index="${index}" ${item.completed ? 'checked' : ''}>
                                            <span>${item.text}</span>
                                        </li>
                                    `).join('') +
                                    `</ul>`;
                }
                
                noteCard.innerHTML = `
                    <h3>${note.title}</h3>
                    <div class="note-meta">
                        <span class="note-subject">${note.subject}</span>
                        <span>${formattedDate}</span>
                    </div>
                    <div class="note-content">${note.content.replace(/\[(x| )\]\s*(.*)/g, '')}</div> ${checklistHtml}
                    ${tagsHtml}
                    <div class="note-actions">
                        <button class="edit-btn" data-id="${note.id}"><i class="fas fa-edit"></i> Edit</button>
                        <button class="archive-toggle-btn" data-id="${note.id}">
                            <i class="fas fa-archive"></i> ${note.isArchived ? 'Unarchive' : 'Archive'}
                        </button>
                        <button class="delete-btn" data-id="${note.id}"><i class="fas fa-trash"></i> Delete</button>
                        <button class="focus-btn" data-id="${note.id}"><i class="fas fa-eye"></i> Focus</button>
                        <button class="export-txt-btn" data-id="${note.id}"><i class="fas fa-file-export"></i> Export TXT</button>
                    </div>
                `;
                notesList.appendChild(noteCard);
            });

            // Add event listeners for checklist checkboxes
            notesList.querySelectorAll('.note-checklist input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const noteId = e.target.dataset.noteId;
                    const checklistIndex = parseInt(e.target.dataset.checklistIndex);
                    const isCompleted = e.target.checked;
                    updateNoteContentWithChecklist(noteId, checklistIndex, isCompleted);
                });
            });

            // Add event listeners for note actions
            notesList.querySelectorAll('.edit-btn').forEach(button => {
                button.addEventListener('click', (e) => editNote(e.target.dataset.id));
            });
            notesList.querySelectorAll('.archive-toggle-btn').forEach(button => {
                button.addEventListener('click', (e) => toggleArchiveNote(e.target.dataset.id));
            });
            notesList.querySelectorAll('.delete-btn').forEach(button => {
                button.addEventListener('click', (e) => deleteNote(e.target.dataset.id));
            });
            notesList.querySelectorAll('.focus-btn').forEach(button => {
                button.addEventListener('click', (e) => toggleFocusMode(e.target.dataset.id));
            });
            notesList.querySelectorAll('.export-txt-btn').forEach(button => {
                button.addEventListener('click', (e) => exportNoteAsTxt(e.target.dataset.id));
            });

            updateProgressTracker();
        }

        function getTagNameWithIcon(tag) {
            switch (tag) {
                case 'Important': return ' Important';
                case 'Revise': return ' Revise';
                case 'To-Do': return ' To-Do';
                case 'Priority': return ' Priority';
                case 'Confusing': return ' Confusing';
                default: return tag;
            }
        }

        function clearNoteForm() {
            noteTitleInput.value = '';
            noteSubjectInput.value = '';
            noteContentTextarea.value = '';
            noteTagCheckboxes.forEach(checkbox => checkbox.checked = false);
        }

        function editNote(id) {
            const noteToEdit = notes.find(note => note.id === id);
            if (!noteToEdit) return;

            // Populate form with note data
            noteTitleInput.value = noteToEdit.title;
            noteSubjectInput.value = noteToEdit.subject;
            noteContentTextarea.value = noteToEdit.content;
            noteTagCheckboxes.forEach(checkbox => {
                checkbox.checked = noteToEdit.tags.includes(checkbox.dataset.tag);
            });

            // Change Add button to Update button
            addNoteButton.textContent = 'Update Note';
            addNoteButton.dataset.editingId = id;
            addNoteButton.removeEventListener('click', addNote);
            addNoteButton.addEventListener('click', updateNote);

            // Scroll to top of form
            addNoteSection.scrollIntoView({ behavior: 'smooth' });
        }

        function updateNote() {
            const id = addNoteButton.dataset.editingId;
            const noteIndex = notes.findIndex(note => note.id === id);
            if (noteIndex === -1) return;

            const updatedTitle = noteTitleInput.value.trim();
            const updatedSubject = noteSubjectInput.value.trim();
            const updatedContent = noteContentTextarea.value.trim();
            const updatedTags = Array.from(noteTagCheckboxes)
                                .filter(checkbox => checkbox.checked)
                                .map(checkbox => checkbox.dataset.tag);

            notes[noteIndex].title = updatedTitle;
            notes[noteIndex].subject = updatedSubject || 'Other';
            notes[noteIndex].content = updatedContent;
            notes[noteIndex].tags = updatedTags;
            notes[noteIndex].checklist = parseChecklistFromContent(updatedContent); // Re-parse checklist

            subjects.add(notes[noteIndex].subject); // Add new subject if it's new
            saveNotepadData();
            clearNoteForm();
            showMessageBox('Note updated successfully!', 'success');

            // Revert button back to Add Note
            addNoteButton.textContent = 'Add Note';
            delete addNoteButton.dataset.editingId;
            addNoteButton.removeEventListener('click', updateNote);
            addNoteButton.addEventListener('click', addNote);
        }

        function toggleArchiveNote(id) {
            const note = notes.find(n => n.id === id);
            if (note) {
                note.isArchived = !note.isArchived;
                saveNotepadData();
                showMessageBox(note.isArchived ? 'Note archived.' : 'Note unarchived.', 'info');
            }
        }

        function deleteNote(id) {
            // Confirmation dialog replacement
            const confirmDelete = () => {
                notes = notes.filter(note => note.id !== id);
                saveNotepadData();
                showMessageBox('Note deleted successfully!', 'success');
            };

            // Simple custom confirmation message for now
            showMessageBox('Are you sure you want to delete this note? (This action is irreversible)', 'info', 5000);
            // In a real app, you'd show a modal with "Confirm" and "Cancel" buttons.
            // For this example, we'll auto-confirm after a short delay for simplicity.
            setTimeout(confirmDelete, 2000); // Auto-delete after 2 seconds for demonstration
        }

        function updateSubjectFilterOptions() {
            filterSubjectSelect.innerHTML = '<option value="all">All Subjects</option>';
            Array.from(subjects).sort().forEach(subject => {
                const option = document.createElement('option');
                option.value = subject;
                option.textContent = subject;
                filterSubjectSelect.appendChild(option);
            });
            // Set the current filter value if it still exists
            filterSubjectSelect.value = currentFilter.subject;
        }

        function applyFiltersAndSort() {
            renderNotes();
            // Update active state of filter buttons
            filterTodayButton.classList.toggle('active-filter', currentFilter.date === 'today');
            filterImportantButton.classList.toggle('active-filter', currentFilter.tag === 'Important');
            filterReviseButton.classList.toggle('active-filter', currentFilter.tag === 'Revise');
            filterTodoPendingButton.classList.toggle('active-filter', currentFilter.todoPending);
            filterArchivedButton.classList.toggle('active-filter', currentFilter.archived);
        }

        function updateProgressTracker() {
            let totalChecklistItems = 0;
            let completedChecklistItems = 0;

            notes.forEach(note => {
                if (note.checklist) {
                    totalChecklistItems += note.checklist.length;
                    completedChecklistItems += note.checklist.filter(item => item.completed).length;
                }
            });

            const percentage = totalChecklistItems === 0 ? 0 : Math.round((completedChecklistItems / totalChecklistItems) * 100);
            completedTasksPercentage.textContent = `${percentage}%`;
            progressBarFill.style.width = `${percentage}%`;
            progressBarFill.textContent = `${percentage}%`;
        }

        function updateThoughtDumpUI() {
            thoughtDumpTextarea.value = thoughtDumpContent;
            thoughtDumpTextarea.addEventListener('input', () => {
                thoughtDumpContent = thoughtDumpTextarea.value;
                localStorage.setItem('thoughtDump', thoughtDumpContent);
            });
            clearThoughtDumpButton.addEventListener('click', () => {
                thoughtDumpContent = "";
                thoughtDumpTextarea.value = "";
                localStorage.setItem('thoughtDump', "");
                localStorage.setItem('lastThoughtDumpClearDate', new Date().toDateString()); // Mark as cleared today
                showMessageBox('Thought dump cleared!', 'info');
            });
        }

        function toggleFocusMode(id = null) {
            notepadContainer.classList.toggle('focus-mode');
            if (notepadContainer.classList.contains('focus-mode')) {
                focusedNoteId = id;
                focusModeToggleButton.textContent = 'Exit Focus Mode';
                // Hide all notes first
                notesList.querySelectorAll('.note-card').forEach(card => {
                    card.classList.remove('focused-note');
                    card.style.display = 'none';
                });
                // Show only the focused note
                if (focusedNoteId) {
                    const focusedCard = notesList.querySelector(`.note-card[data-id="${focusedNoteId}"]`);
                    if (focusedCard) {
                        focusedCard.classList.add('focused-note');
                        focusedCard.style.display = 'flex'; // Ensure it's visible
                    }
                } else {
                    // If no specific note ID, show all notes in a stacked view
                    notesList.querySelectorAll('.note-card').forEach(card => {
                        card.style.display = 'flex';
                    });
                }
            } else {
                focusedNoteId = null;
                focusModeToggleButton.textContent = 'Enter Focus Mode';
                notesList.querySelectorAll('.note-card').forEach(card => {
                    card.classList.remove('focused-note');
                    card.style.display = 'flex'; // Restore default display
                });
                renderNotes(); // Re-render to apply normal filters/sort
            }
        }

        function exportNoteAsTxt(id) {
            const note = notes.find(n => n.id === id);
            if (!note) {
                showMessageBox('Note not found for export.', 'error');
                return;
            }

            let textContent = `Title: ${note.title}\n`;
            textContent += `Subject: ${note.subject}\n`;
            textContent += `Created At: ${new Date(note.createdAt).toLocaleString()}\n`;
            if (note.tags && note.tags.length > 0) {
                textContent += `Tags: ${note.tags.join(', ')}\n`;
            }
            textContent += `\nContent:\n${note.content}\n`;

            if (note.checklist && note.checklist.length > 0) {
                textContent += `\nChecklist:\n`;
                note.checklist.forEach(item => {
                    textContent += `- [${item.completed ? 'x' : ' '}] ${item.text}\n`;
                });
            }

            const blob = new Blob([textContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${note.title.replace(/[^a-z0-9]/gi, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            showMessageBox('Note exported as TXT!', 'success');
        }

        function backupAllNotesAsJson() {
            const dataStr = JSON.stringify(notes, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            const date = new Date().toISOString().slice(0, 10);
            a.download = `evexa_buddy_notes_backup_${date}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            showMessageBox('All notes backed up as JSON!', 'success');
        }


        document.addEventListener('DOMContentLoaded', () => {
            // Assign DOM elements to global variables (Flappy Bird)
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            scoreDisplay = document.getElementById('score-display');
            gameOverScreen = document.getElementById('game-over-screen');
            finalScoreDisplay = document.getElementById('final-score');
            highScoreDisplay = document.getElementById('high-score');
            restartButton = document.getElementById('restart-button');
            countdownDisplay = document.getElementById('countdown-display');
            levelUpDisplay = document.getElementById('level-up-display');
            rotationHint = document.getElementById('rotation-hint');
            
            gamePage = document.getElementById('game-page');
            gameSelectionPage = document.getElementById('game-selection-page'); // Get game selection page
            gameStartOverlay = document.getElementById('game-start-overlay');
            dynamicGameContainer = document.getElementById('dynamic-game-container'); // Get the new container

            // Game control buttons (Flappy Bird)
            pauseResumeButton = document.getElementById('pause-resume-button');
            stopButton = document.getElementById('stop-button');
            rotateButton = document.getElementById('rotate-button');
            flappyBirdGameElements = document.querySelectorAll('.flappy-bird-game-elements'); // Get all Flappy Bird specific elements

            const playPortraitButton = document.getElementById('play-portrait-button');
            const rotateAndPlayButton = document.getElementById('rotate-and-play-button');

            // User Profile and Pro status
            proBadge = document.getElementById('pro-badge');
            toggleProButton = document.getElementById('toggle-pro-button');

            // Sidebar elements
            const sidebar = document.getElementById('sidebar');
            const menuToggleButton = document.getElementById('menuToggleButton');
            const sidebarToggleDesktop = document.getElementById('sidebarToggleDesktop');
            const postsMenuItem = document.getElementById('postsMenuItem');
            const themeToggleButton = document.getElementById('theme-toggle');

            // Bottom Navbar elements
            const bottomNavbar = document.getElementById('bottomNavbar');
            const navLinks = document.querySelectorAll('.sidebar nav ul li a, .bottom-navbar-container .bottom-nav-item');
            const gameCards = document.querySelectorAll('.game-card'); // Get all game cards

            // Smart Notepad DOM Elements
            smartNotepadPage = document.getElementById('smart-notepad-page');
            notepadContainer = document.getElementById('notepad-container');
            addNoteSection = document.getElementById('add-note-section');
            notesList = document.getElementById('notes-list');
            noNotesMessage = document.getElementById('no-notes-message');

            noteTitleInput = document.getElementById('note-title');
            noteSubjectInput = document.getElementById('note-subject');
            noteContentTextarea = document.getElementById('note-content');
            noteTagCheckboxes = document.querySelectorAll('.tag-group input[type="checkbox"]');
            addNoteButton = document.getElementById('add-note-button');
            clearFormButton = document.getElementById('clear-form-button');
            subjectSuggestionsDatalist = document.getElementById('subject-suggestions');

            filterSubjectSelect = document.getElementById('filter-subject');
            sortDateSelect = document.getElementById('sort-date');
            filterTodayButton = document.getElementById('filter-today');
            filterImportantButton = document.getElementById('filter-important');
            filterReviseButton = document.getElementById('filter-revise');
            filterTodoPendingButton = document.getElementById('filter-todo-pending');
            filterArchivedButton = document.getElementById('filter-archived');
            clearFiltersButton = document.getElementById('clear-filters-button');

            progressTrackerSection = document.getElementById('progress-tracker-section');
            completedTasksPercentage = document.getElementById('completed-tasks-percentage');
            progressBarFill = document.getElementById('progress-bar-fill');

            thoughtDumpTextarea = document.getElementById('thought-dump-textarea');
            clearThoughtDumpButton = document.getElementById('clear-thought-dump-button');

            focusModeToggleButton = document.getElementById('focus-mode-toggle-button');
            exportNoteButton = document.getElementById('export-note-button');
            backupAllNotesButton = document.getElementById('backup-all-notes-button');


            // Attach event listeners to start audio context on first interaction
            document.addEventListener('click', startAudioContext); 
            document.addEventListener('keydown', startAudioContext); 
            document.addEventListener('touchstart', startAudioContext); 

            // Event Listeners for Flappy Bird
            document.addEventListener('keydown', (e) => {
                // Prevent default scrolling for Space, Enter, and Arrow keys when game page is active
                if (gamePage.classList.contains('active') && gamePage.classList.contains('flappy-bird-active')) {
                    if (e.code === 'Space' || e.key === 'Enter' || 
                        e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
                        e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        e.preventDefault();
                    }
                    // Only jump if Flappy Bird is playing or on start overlay
                    if (e.code === 'Space' && (currentGameState === GAME_STATES.PLAYING || currentGameState === GAME_STATES.GAME_START_OVERLAY)) {
                        jump();
                    }
                }
            });

            // Unified click/tap handler for Flappy Bird jump (now also triggers game start overlay logic)
            if (gameStartOverlay) { // Check if element exists before adding listener
                gameStartOverlay.addEventListener('click', jump);
                gameStartOverlay.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scrolling on touch
                    jump();
                });
            }
            if (canvas) { // Check if element exists before adding listener
                canvas.addEventListener('click', jump);
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    jump();
                });
            }


            // Restart button now directly re-initializes the game (which starts countdown)
            if (restartButton) restartButton.addEventListener('click', initGame);

            // Game control button event listeners (Flappy Bird)
            if (pauseResumeButton) {
                pauseResumeButton.addEventListener('click', togglePauseResume);
            }
            if (stopButton) {
                stopButton.addEventListener('click', stopGame);
            }
            if (rotateButton) {
                rotateButton.addEventListener('click', toggleRotation);
            }

            // User Profile and Pro status
            let isProUser = JSON.parse(localStorage.getItem('isProUser')) || false;
            if (isProUser) {
                proBadge.classList.add('active');
                toggleProButton.textContent = 'Downgrade to Free';
            } else {
                proBadge.classList.remove('active');
                toggleProButton.textContent = 'Upgrade to Pro';
            }
            
            if (toggleProButton) {
                toggleProButton.addEventListener('click', toggleProStatus);
            }

            // Game card click handlers
            gameCards.forEach(card => {
                card.addEventListener('click', async (e) => { // Made async to await fetch
                    e.preventDefault();
                    const gameId = card.dataset.game;
                    showPage('game-page'); // Always navigate to game-page first

                    if (gameId === 'flappy-bird') {
                        // Show Flappy Bird elements and initialize
                        flappyBirdGameElements.forEach(el => el.style.display = '');
                        gamePage.classList.add('flappy-bird-active');
                        dynamicGameContainer.innerHTML = ''; // Clear other game content
                        await initGame(); // Initialize Flappy Bird
                    } else if (gameId === 'whack-a-mole') {
                        // Hide Flappy Bird elements
                        flappyBirdGameElements.forEach(el => el.style.display = 'none');
                        gamePage.classList.remove('flappy-bird-active');
                        // Initialize Whack-a-Mole
                        initializeWhackAMoleGame();
                    } else if (gameId === 'space-miner') {
                        // Hide Flappy Bird elements
                        flappyBirdGameElements.forEach(el => el.style.display = 'none');
                        gamePage.classList.remove('flappy-bird-active');
                        // Initialize Space Miner
                        initializeSpaceMinerGame();
                    } else if (gameId === 'city-runner') { // New City Runner game
                        // Hide Flappy Bird elements
                        flappyBirdGameElements.forEach(el => el.style.display = 'none');
                        gamePage.classList.remove('flappy-bird-active');
                        // Initialize City Runner
                        initializeCityRunnerGame();
                    }
                    else {
                        // For other games, show a message box (instead of alert)
                        showMessageBox(`The game "${card.querySelector('h3').textContent}" is coming soon!`);
                    }
                });
            });

            // Rotation hint buttons
            if (playPortraitButton) {
                playPortraitButton.addEventListener('click', () => {
                    rotationHintDismissed = true;
                    userPrefersRotation = false; // User explicitly opted out of rotation
                    localStorage.setItem('userPrefersRotation', false); // Save preference
                    rotationHint.classList.remove('active');
                    gameStartOverlay.classList.add('hidden'); // Hide "Tap to Play"
                    startCountdown(); // Start the game
                });
            }
            if (rotateAndPlayButton) {
                rotateAndPlayButton.addEventListener('click', () => {
                    rotationHintDismissed = true;
                    userPrefersRotation = true; // User explicitly opted in for rotation
                    localStorage.setItem('userPrefersRotation', true); // Save preference
                    rotationHint.classList.remove('active');
                    gameStartOverlay.classList.add('hidden'); // Hide "Tap to Play"
                    startCountdown(); // Start the game
                });
            }

            // Navigation links
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const pageId = link.dataset.page;
                    if (pageId) {
                        showPage(pageId);
                    }
                    // For mobile, close sidebar after navigation
                    if (window.innerWidth < 769) {
                        sidebar.classList.remove('active');
                    }
                });
            });

            // Sidebar Menu Toggle for small screens (hamburger icon)
            if (menuToggleButton) {
                menuToggleButton.addEventListener('click', () => {
                    sidebar.classList.toggle('active');
                });
            }

            // Sidebar Toggle for Desktop (chevron icon)
            if (sidebarToggleDesktop) {
                sidebarToggleDesktop.addEventListener('click', () => {
                    sidebar.classList.toggle('expanded');
                    // Update icon based on state
                    if (sidebar.classList.contains('expanded')) {
                        sidebarToggleDesktop.innerHTML = '<i class="fas fa-chevron-left"></i>';
                    } else {
                        sidebarToggleDesktop.innerHTML = '<i class="fas fa-chevron-right"></i>';
                    }
                });
            }

            // Posts Sub-menu Toggle
            if (postsMenuItem) {
                const postsToggleButton = postsMenuItem.querySelector('.menu-item-toggle');
                if (postsToggleButton) {
                    postsToggleButton.addEventListener('click', () => {
                        postsMenuItem.classList.toggle('expanded');
                    });
                }
            }

            // Theme toggle functionality
            if (themeToggleButton) {
                themeToggleButton.addEventListener('click', () => {
                    document.body.classList.toggle('light-mode');
                    if (document.body.classList.contains('light-mode')) {
                        localStorage.setItem('theme', 'light');
                        themeToggleButton.textContent = 'Toggle Dark Mode'; // Update button text
                    } else {
                        localStorage.setItem('theme', 'dark');
                        themeToggleButton.textContent = 'Toggle Light Mode'; // Update button text
                    }
                });
            }

            // Apply saved theme preference on load
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                if (themeToggleButton) themeToggleButton.textContent = 'Toggle Dark Mode';
            } else {
                document.body.classList.remove('light-mode');
                if (themeToggleButton) themeToggleButton.textContent = 'Toggle Light Mode';
            }

            // Initial setup: show smart notepad page
            showPage('smart-notepad-page');

            // Handle window resize and orientation change
            window.addEventListener('resize', () => {
                checkOrientation(); // Check orientation on resize
            });
            window.addEventListener('orientationchange', checkOrientation); // For explicit orientation changes

            // Initial check on load, after all elements are ready
            checkOrientation(); 

            // Smart Notepad Event Listeners
            addNoteButton.addEventListener('click', addNote);
            clearFormButton.addEventListener('click', clearNoteForm);

            filterSubjectSelect.addEventListener('change', (e) => {
                currentFilter.subject = e.target.value;
                applyFiltersAndSort();
            });
            sortDateSelect.addEventListener('change', (e) => {
                currentSort = e.target.value;
                applyFiltersAndSort();
            });

            filterTodayButton.addEventListener('click', () => {
                currentFilter.date = currentFilter.date === 'today' ? 'all' : 'today';
                applyFiltersAndSort();
            });
            filterImportantButton.addEventListener('click', () => {
                currentFilter.tag = currentFilter.tag === 'Important' ? 'all' : 'Important';
                applyFiltersAndSort();
            });
            filterReviseButton.addEventListener('click', () => {
                currentFilter.tag = currentFilter.tag === 'Revise' ? 'all' : 'Revise';
                applyFiltersAndSort();
            });
            filterTodoPendingButton.addEventListener('click', () => {
                currentFilter.todoPending = !currentFilter.todoPending;
                applyFiltersAndSort();
            });
            filterArchivedButton.addEventListener('click', () => {
                currentFilter.archived = !currentFilter.archived;
                applyFiltersAndSort();
            });
            clearFiltersButton.addEventListener('click', () => {
                currentFilter = {
                    subject: 'all',
                    tag: 'all',
                    date: 'all',
                    todoPending: false,
                    archived: false
                };
                currentSort = 'newest';
                filterSubjectSelect.value = 'all';
                sortDateSelect.value = 'newest';
                applyFiltersAndSort();
            });

            focusModeToggleButton.addEventListener('click', () => toggleFocusMode());
            exportNoteButton.addEventListener('click', () => {
                // For export, if no note is explicitly selected, try to export the first visible one
                const visibleNotes = notesList.querySelectorAll('.note-card:not([style*="display: none"])');
                if (visibleNotes.length > 0) {
                    exportNoteAsTxt(visibleNotes[0].dataset.id);
                } else {
                    showMessageBox('No note visible to export. Please select a note or add one.', 'error');
                }
            });
            backupAllNotesButton.addEventListener('click', backupAllNotesAsJson);

            // Initial load and render for Notepad
            loadNotepadData();
            updateSubjectFilterOptions();
            renderNotes();
            updateThoughtDumpUI();
            updateProgressTracker();
        });

        // Custom Message Box (replacement for alert/confirm)
        function showMessageBox(message, type = 'info', duration = 3000) {
            let messageBox = document.getElementById('custom-message-box');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'custom-message-box';
                messageBox.style.cssText = `
                    position: fixed;
                    bottom: 100px; /* Above bottom navbar */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: var(--primary-color);
                    color: white;
                    padding: 15px 25px;
                    border-radius: 10px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                    font-size: 1.1em;
                    font-weight: 600;
                    z-index: 1000;
                    opacity: 0;
                    visibility: hidden;
                    transition: opacity 0.3s ease, transform 0.3s ease;
                    max-width: 90vw;
                    text-align: center;
                `;
                document.body.appendChild(messageBox);
            }

            messageBox.textContent = message;
            messageBox.style.backgroundColor = type === 'error' ? 'var(--danger-color)' : (type === 'success' ? 'var(--success-color)' : 'var(--primary-color)');
            messageBox.style.opacity = '1';
            messageBox.style.visibility = 'visible';
            messageBox.style.transform = 'translateX(-50%) translateY(0)';

            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.transform = 'translateX(-50%) translateY(20px)';
                messageBox.addEventListener('transitionend', function handler() {
                    messageBox.style.visibility = 'hidden';
                    messageBox.removeEventListener('transitionend', handler);
                });
            }, duration);
        }

        // Custom Font Awesome icon for Flappy Bird
        // This is a workaround as Font Awesome doesn't have a direct flappy bird icon.
        // We'll use a generic bird and style it.
        // Or, better, use an inline SVG for better control.
        // For simplicity and consistency with Font Awesome, we'll keep the generic bird for now.
        // If a custom icon is needed, it would be an SVG.
        // For now, let's just use a generic bird icon for Flappy Bird.
        // The fas fa-flappy-bird class is a placeholder and won't render unless defined.
        // We will use fas fa-bird or fas fa-dove or create a custom SVG.
        // Let's use fas fa-feather-alt as it's more abstract and fits the game theme.
        // Update: Changed fas fa-flappy-bird to fas fa-feather-alt in HTML.
    </script>
</body>
</html>
